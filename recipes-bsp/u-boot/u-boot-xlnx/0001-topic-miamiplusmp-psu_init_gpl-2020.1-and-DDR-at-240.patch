From a1dcf822e1981deab061ed27421e4d223991457a Mon Sep 17 00:00:00 2001
From: Mike Looijmans <mike.looijmans@topic.nl>
Date: Mon, 22 Jun 2020 14:54:48 +0200
Subject: [PATCH] topic-miamiplusmp: psu_init_gpl 2020.1 and DDR at 2400

---
 .../zynqmp-topic-miamiplusmp/psu_init_gpl.c   | 1036 ++++++++++++++++-
 .../zynqmp-topic-miamiplusmp/psu_init_gpl.h   |  106 +-
 2 files changed, 1042 insertions(+), 100 deletions(-)

diff --git a/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.c b/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.c
index 35dc6d8489..a9aa363e6a 100644
--- a/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.c
+++ b/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.c
@@ -6,6 +6,11 @@
 #include <asm/arch/psu_init_gpl.h>
 #include <xil_io.h>
 
+static int serdes_illcalib(u32 lane3_protocol, u32 lane3_rate,
+			   u32 lane2_protocol, u32 lane2_rate,
+			   u32 lane1_protocol, u32 lane1_rate,
+			   u32 lane0_protocol, u32 lane0_rate);
+
 static unsigned long psu_pll_init_data(void)
 {
 	psu_mask_write(0xFF5E0034, 0xFE7FEDEFU, 0x7E4E2C62U);
@@ -34,13 +39,13 @@ static unsigned long psu_pll_init_data(void)
 	psu_mask_write(0xFD1A0020, 0x00000008U, 0x00000000U);
 	psu_mask_write(0xFD1A0048, 0x00003F00U, 0x00000300U);
 	psu_mask_write(0xFD1A0030, 0xFE7FEDEFU, 0x7E4B0C62U);
-	psu_mask_write(0xFD1A002C, 0x00717F00U, 0x00014000U);
+	psu_mask_write(0xFD1A002C, 0x00717F00U, 0x00014800U);
 	psu_mask_write(0xFD1A002C, 0x00000008U, 0x00000008U);
 	psu_mask_write(0xFD1A002C, 0x00000001U, 0x00000001U);
 	psu_mask_write(0xFD1A002C, 0x00000001U, 0x00000000U);
 	mask_poll(0xFD1A0044, 0x00000002U);
 	psu_mask_write(0xFD1A002C, 0x00000008U, 0x00000000U);
-	psu_mask_write(0xFD1A004C, 0x00003F00U, 0x00000200U);
+	psu_mask_write(0xFD1A004C, 0x00003F00U, 0x00000300U);
 	psu_mask_write(0xFD1A003C, 0xFE7FEDEFU, 0x7E4B0C62U);
 	psu_mask_write(0xFD1A0038, 0x00717F00U, 0x00014800U);
 	psu_mask_write(0xFD1A0038, 0x00000008U, 0x00000008U);
@@ -92,7 +97,7 @@ static unsigned long psu_clock_init_data(void)
 	psu_mask_write(0xFD1A0084, 0x07003F07U, 0x07000202U);
 	psu_mask_write(0xFD1A00B8, 0x01003F07U, 0x01000200U);
 	psu_mask_write(0xFD1A00BC, 0x01003F07U, 0x01000200U);
-	psu_mask_write(0xFD1A00C0, 0x01003F07U, 0x01000203U);
+	psu_mask_write(0xFD1A00C0, 0x01003F07U, 0x01000300U);
 	psu_mask_write(0xFD1A00C4, 0x01003F07U, 0x01000502U);
 	psu_mask_write(0xFD1A00F8, 0x00003F07U, 0x00000200U);
 	psu_mask_write(0xFF180380, 0x000000FFU, 0x00000000U);
@@ -108,50 +113,50 @@ static unsigned long psu_ddr_init_data(void)
 	psu_mask_write(0xFD1A0108, 0x00000008U, 0x00000008U);
 	psu_mask_write(0xFD070000, 0xE30FBE3DU, 0x81040010U);
 	psu_mask_write(0xFD070010, 0x8000F03FU, 0x00000030U);
-	psu_mask_write(0xFD070020, 0x000003F3U, 0x00000200U);
+	psu_mask_write(0xFD070020, 0x000003F3U, 0x00000300U);
 	psu_mask_write(0xFD070024, 0xFFFFFFFFU, 0x00800000U);
 	psu_mask_write(0xFD070030, 0x0000007FU, 0x00000000U);
-	psu_mask_write(0xFD070034, 0x00FFFF1FU, 0x00408410U);
+	psu_mask_write(0xFD070034, 0x00FFFF1FU, 0x00409410U);
 	psu_mask_write(0xFD070050, 0x00F1F1F4U, 0x00210000U);
 	psu_mask_write(0xFD070054, 0x0FFF0FFFU, 0x00000000U);
 	psu_mask_write(0xFD070060, 0x00000073U, 0x00000001U);
-	psu_mask_write(0xFD070064, 0x0FFF83FFU, 0x008180BBU);
+	psu_mask_write(0xFD070064, 0x0FFF83FFU, 0x009280D2U);
 	psu_mask_write(0xFD070070, 0x00000017U, 0x00000010U);
 	psu_mask_write(0xFD070074, 0x00000003U, 0x00000000U);
 	psu_mask_write(0xFD0700C4, 0x3F000391U, 0x10000200U);
-	psu_mask_write(0xFD0700C8, 0x01FF1F3FU, 0x0040051FU);
-	psu_mask_write(0xFD0700D0, 0xC3FF0FFFU, 0x00020106U);
+	psu_mask_write(0xFD0700C8, 0x01FF1F3FU, 0x0048051FU);
+	psu_mask_write(0xFD0700D0, 0xC3FF0FFFU, 0x00020126U);
 	psu_mask_write(0xFD0700D4, 0x01FF7F0FU, 0x00020000U);
-	psu_mask_write(0xFD0700D8, 0x0000FF0FU, 0x00002305U);
-	psu_mask_write(0xFD0700DC, 0xFFFFFFFFU, 0x07340301U);
-	psu_mask_write(0xFD0700E0, 0xFFFFFFFFU, 0x00200200U);
+	psu_mask_write(0xFD0700D8, 0x0000FF0FU, 0x00002705U);
+	psu_mask_write(0xFD0700DC, 0xFFFFFFFFU, 0x09400301U);
+	psu_mask_write(0xFD0700E0, 0xFFFFFFFFU, 0x00280200U);
 	psu_mask_write(0xFD0700E4, 0x00FF03FFU, 0x00210004U);
 	psu_mask_write(0xFD0700E8, 0xFFFFFFFFU, 0x000006C0U);
 	psu_mask_write(0xFD0700EC, 0xFFFF0000U, 0x08190000U);
 	psu_mask_write(0xFD0700F0, 0x0000003FU, 0x00000010U);
 	psu_mask_write(0xFD0700F4, 0x00000FFFU, 0x0000066FU);
-	psu_mask_write(0xFD070100, 0x7F3F7F3FU, 0x11102412U);
-	psu_mask_write(0xFD070104, 0x001F1F7FU, 0x0004041AU);
-	psu_mask_write(0xFD070108, 0x3F3F3F3FU, 0x0708060DU);
+	psu_mask_write(0xFD070100, 0x7F3F7F3FU, 0x13122813U);
+	psu_mask_write(0xFD070104, 0x001F1F7FU, 0x0004041DU);
+	psu_mask_write(0xFD070108, 0x3F3F3F3FU, 0x0809060FU);
 	psu_mask_write(0xFD07010C, 0x3FF3F3FFU, 0x0050400CU);
-	psu_mask_write(0xFD070110, 0x1F0F0F1FU, 0x08030409U);
+	psu_mask_write(0xFD070110, 0x1F0F0F1FU, 0x0903040AU);
 	psu_mask_write(0xFD070114, 0x0F0F3F1FU, 0x06060403U);
 	psu_mask_write(0xFD070118, 0x0F0F000FU, 0x01010004U);
 	psu_mask_write(0xFD07011C, 0x00000F0FU, 0x00000606U);
-	psu_mask_write(0xFD070120, 0x7F7F7F7FU, 0x04040D07U);
-	psu_mask_write(0xFD070124, 0x40070F3FU, 0x0002030BU);
-	psu_mask_write(0xFD07012C, 0x7F1F031FU, 0x1207010EU);
+	psu_mask_write(0xFD070120, 0x7F7F7F7FU, 0x05050D08U);
+	psu_mask_write(0xFD070124, 0x40070F3FU, 0x0002040CU);
+	psu_mask_write(0xFD07012C, 0x7F1F031FU, 0x1308010EU);
 	psu_mask_write(0xFD070130, 0x00030F1FU, 0x00020608U);
 	psu_mask_write(0xFD070180, 0xF7FF03FFU, 0x81000040U);
-	psu_mask_write(0xFD070184, 0x3FFFFFFFU, 0x020196E5U);
-	psu_mask_write(0xFD070190, 0x1FBFBF3FU, 0x048C820BU);
+	psu_mask_write(0xFD070184, 0x3FFFFFFFU, 0x0201C9C2U);
+	psu_mask_write(0xFD070190, 0x1FBFBF3FU, 0x048E820DU);
 	psu_mask_write(0xFD070194, 0xF31F0F0FU, 0x00030304U);
 	psu_mask_write(0xFD070198, 0x0FF1F1F1U, 0x07000101U);
 	psu_mask_write(0xFD07019C, 0x000000F1U, 0x00000021U);
 	psu_mask_write(0xFD0701A0, 0xC3FF03FFU, 0x00400003U);
 	psu_mask_write(0xFD0701A4, 0x00FF00FFU, 0x00C800FFU);
 	psu_mask_write(0xFD0701B0, 0x00000007U, 0x00000000U);
-	psu_mask_write(0xFD0701B4, 0x00003F3FU, 0x00000A09U);
+	psu_mask_write(0xFD0701B4, 0x00003F3FU, 0x00000C0BU);
 	psu_mask_write(0xFD0701C0, 0x00000007U, 0x00000001U);
 	psu_mask_write(0xFD070200, 0x0000001FU, 0x0000001FU);
 	psu_mask_write(0xFD070204, 0x001F1F1FU, 0x001F0909U);
@@ -223,30 +228,30 @@ static unsigned long psu_ddr_init_data(void)
 	psu_mask_write(0xFD072190, 0x1FBFBF3FU, 0x07828002U);
 	psu_mask_write(0xFD1A0108, 0x0000000CU, 0x00000000U);
 	psu_mask_write(0xFD080010, 0xFFFFFFFFU, 0x07001E00U);
-	psu_mask_write(0xFD080018, 0xFFFFFFFFU, 0x00F10010U);
+	psu_mask_write(0xFD080018, 0xFFFFFFFFU, 0x00F12090U);
 	psu_mask_write(0xFD08001C, 0xFFFFFFFFU, 0x55AA5480U);
 	psu_mask_write(0xFD080024, 0xFFFFFFFFU, 0x010100F4U);
-	psu_mask_write(0xFD080040, 0xFFFFFFFFU, 0x42C21590U);
-	psu_mask_write(0xFD080044, 0xFFFFFFFFU, 0xD05512C0U);
-	psu_mask_write(0xFD080068, 0xFFFFFFFFU, 0x01100000U);
+	psu_mask_write(0xFD080040, 0xFFFFFFFFU, 0x4B025810U);
+	psu_mask_write(0xFD080044, 0xFFFFFFFFU, 0xEA601518U);
+	psu_mask_write(0xFD080068, 0xFFFFFFFFU, 0x000E0000U);
 	psu_mask_write(0xFD080090, 0xFFFFFFFFU, 0x02A04161U);
 	psu_mask_write(0xFD0800C0, 0xFFFFFFFFU, 0x00000000U);
-	psu_mask_write(0xFD0800C4, 0xFFFFFFFFU, 0x000000E0U);
+	psu_mask_write(0xFD0800C4, 0xFFFFFFFFU, 0x000000E3U);
 	psu_mask_write(0xFD080100, 0xFFFFFFFFU, 0x0800040CU);
-	psu_mask_write(0xFD080110, 0xFFFFFFFFU, 0x07241008U);
-	psu_mask_write(0xFD080114, 0xFFFFFFFFU, 0x28200008U);
+	psu_mask_write(0xFD080110, 0xFFFFFFFFU, 0x08261209U);
+	psu_mask_write(0xFD080114, 0xFFFFFFFFU, 0x28240008U);
 	psu_mask_write(0xFD080118, 0xFFFFFFFFU, 0x000F0300U);
 	psu_mask_write(0xFD08011C, 0xFFFFFFFFU, 0x83000800U);
-	psu_mask_write(0xFD080120, 0xFFFFFFFFU, 0x01762B07U);
-	psu_mask_write(0xFD080124, 0xFFFFFFFFU, 0x00331008U);
-	psu_mask_write(0xFD080128, 0xFFFFFFFFU, 0x00000E10U);
+	psu_mask_write(0xFD080120, 0xFFFFFFFFU, 0x01A42B08U);
+	psu_mask_write(0xFD080124, 0xFFFFFFFFU, 0x00391209U);
+	psu_mask_write(0xFD080128, 0xFFFFFFFFU, 0x00001012U);
 	psu_mask_write(0xFD080140, 0xFFFFFFFFU, 0x08400020U);
 	psu_mask_write(0xFD080144, 0xFFFFFFFFU, 0x00000C80U);
 	psu_mask_write(0xFD080150, 0xFFFFFFFFU, 0x00000000U);
-	psu_mask_write(0xFD080154, 0xFFFFFFFFU, 0x00000200U);
-	psu_mask_write(0xFD080180, 0xFFFFFFFFU, 0x00000634U);
+	psu_mask_write(0xFD080154, 0xFFFFFFFFU, 0x00000300U);
+	psu_mask_write(0xFD080180, 0xFFFFFFFFU, 0x00000840U);
 	psu_mask_write(0xFD080184, 0xFFFFFFFFU, 0x00000301U);
-	psu_mask_write(0xFD080188, 0xFFFFFFFFU, 0x00000020U);
+	psu_mask_write(0xFD080188, 0xFFFFFFFFU, 0x00000028U);
 	psu_mask_write(0xFD08018C, 0xFFFFFFFFU, 0x00000200U);
 	psu_mask_write(0xFD080190, 0xFFFFFFFFU, 0x00000000U);
 	psu_mask_write(0xFD080194, 0xFFFFFFFFU, 0x000006C0U);
@@ -275,7 +280,7 @@ static unsigned long psu_ddr_init_data(void)
 	psu_mask_write(0xFD08055C, 0xFFFFFFFFU, 0x00000000U);
 	psu_mask_write(0xFD080560, 0xFFFFFFFFU, 0x00000000U);
 	psu_mask_write(0xFD080564, 0xFFFFFFFFU, 0x00000000U);
-	psu_mask_write(0xFD080680, 0xFFFFFFFFU, 0x008AAA58U);
+	psu_mask_write(0xFD080680, 0xFFFFFFFFU, 0x008AEA58U);
 	psu_mask_write(0xFD080684, 0xFFFFFFFFU, 0x000079DDU);
 	psu_mask_write(0xFD080694, 0xFFFFFFFFU, 0x01E10210U);
 	psu_mask_write(0xFD080698, 0xFFFFFFFFU, 0x01E10000U);
@@ -340,27 +345,27 @@ static unsigned long psu_ddr_init_data(void)
 	psu_mask_write(0xFD080F14, 0xFFFFFFFFU, 0x09094F4FU);
 	psu_mask_write(0xFD080F18, 0xFFFFFFFFU, 0x09092B2BU);
 	psu_mask_write(0xFD081400, 0xFFFFFFFFU, 0x2A019FFEU);
-	psu_mask_write(0xFD081404, 0xFFFFFFFFU, 0x01100000U);
+	psu_mask_write(0xFD081404, 0xFFFFFFFFU, 0x000E0000U);
 	psu_mask_write(0xFD08141C, 0xFFFFFFFFU, 0x01264300U);
 	psu_mask_write(0xFD08142C, 0xFFFFFFFFU, 0x00041800U);
 	psu_mask_write(0xFD081430, 0xFFFFFFFFU, 0x70800000U);
 	psu_mask_write(0xFD081440, 0xFFFFFFFFU, 0x2A019FFEU);
-	psu_mask_write(0xFD081444, 0xFFFFFFFFU, 0x01100000U);
+	psu_mask_write(0xFD081444, 0xFFFFFFFFU, 0x000E0000U);
 	psu_mask_write(0xFD08145C, 0xFFFFFFFFU, 0x01264300U);
 	psu_mask_write(0xFD08146C, 0xFFFFFFFFU, 0x00041800U);
 	psu_mask_write(0xFD081470, 0xFFFFFFFFU, 0x70800000U);
 	psu_mask_write(0xFD081480, 0xFFFFFFFFU, 0x2A019FFEU);
-	psu_mask_write(0xFD081484, 0xFFFFFFFFU, 0x01100000U);
+	psu_mask_write(0xFD081484, 0xFFFFFFFFU, 0x000E0000U);
 	psu_mask_write(0xFD08149C, 0xFFFFFFFFU, 0x01264300U);
 	psu_mask_write(0xFD0814AC, 0xFFFFFFFFU, 0x00041800U);
 	psu_mask_write(0xFD0814B0, 0xFFFFFFFFU, 0x70800000U);
 	psu_mask_write(0xFD0814C0, 0xFFFFFFFFU, 0x2A019FFEU);
-	psu_mask_write(0xFD0814C4, 0xFFFFFFFFU, 0x01100000U);
+	psu_mask_write(0xFD0814C4, 0xFFFFFFFFU, 0x000E0000U);
 	psu_mask_write(0xFD0814DC, 0xFFFFFFFFU, 0x01264300U);
 	psu_mask_write(0xFD0814EC, 0xFFFFFFFFU, 0x00041800U);
 	psu_mask_write(0xFD0814F0, 0xFFFFFFFFU, 0x70800000U);
 	psu_mask_write(0xFD081500, 0xFFFFFFFFU, 0x15019FFEU);
-	psu_mask_write(0xFD081504, 0xFFFFFFFFU, 0x21100000U);
+	psu_mask_write(0xFD081504, 0xFFFFFFFFU, 0x200E0000U);
 	psu_mask_write(0xFD08151C, 0xFFFFFFFFU, 0x01266300U);
 	psu_mask_write(0xFD08152C, 0xFFFFFFFFU, 0x00041800U);
 	psu_mask_write(0xFD081530, 0xFFFFFFFFU, 0x70400000U);
@@ -482,7 +487,7 @@ static unsigned long psu_mio_init_data(void)
 	psu_mask_write(0xFF180158, 0x03FFFFFFU, 0x03FFFFFFU);
 	psu_mask_write(0xFF18015C, 0x03FFFFFFU, 0x00000000U);
 	psu_mask_write(0xFF180160, 0x01FFFF9FU, 0x01FFFF9FU);
-	psu_mask_write(0xFF180164, 0x03FFFFFFU, 0x03F9F7FFU);
+	psu_mask_write(0xFF180164, 0x03FFFFFFU, 0x03E7DFFFU);
 	psu_mask_write(0xFF180168, 0x03FFFFFFU, 0x00000000U);
 	psu_mask_write(0xFF180170, 0x03FFFFFFU, 0x03FFFFFFU);
 	psu_mask_write(0xFF180174, 0x03FFFFFFU, 0x03FFFFFFU);
@@ -526,12 +531,12 @@ static unsigned long psu_peripherals_init_data(void)
 	psu_mask_write(0xFF5E0238, 0x00000018U, 0x00000000U);
 	psu_mask_write(0xFF5E0238, 0x00007800U, 0x00000000U);
 	psu_mask_write(0xFF5E0238, 0x00000006U, 0x00000000U);
-	psu_mask_write(0xFF000034, 0x000000FFU, 0x00000005U);
-	psu_mask_write(0xFF000018, 0x0000FFFFU, 0x0000008FU);
+	psu_mask_write(0xFF000034, 0x000000FFU, 0x00000006U);
+	psu_mask_write(0xFF000018, 0x0000FFFFU, 0x0000007CU);
 	psu_mask_write(0xFF000000, 0x000001FFU, 0x00000017U);
 	psu_mask_write(0xFF000004, 0x000003FFU, 0x00000020U);
-	psu_mask_write(0xFF010034, 0x000000FFU, 0x00000005U);
-	psu_mask_write(0xFF010018, 0x0000FFFFU, 0x0000008FU);
+	psu_mask_write(0xFF010034, 0x000000FFU, 0x00000006U);
+	psu_mask_write(0xFF010018, 0x0000FFFFU, 0x0000007CU);
 	psu_mask_write(0xFF010000, 0x000001FFU, 0x00000017U);
 	psu_mask_write(0xFF010004, 0x000003FFU, 0x00000020U);
 	psu_mask_write(0xFF5E0238, 0x00040000U, 0x00000000U);
@@ -662,6 +667,8 @@ static unsigned long psu_serdes_init_data(void)
 	psu_mask_write(0xFD405978, 0x00000010U, 0x00000010U);
 	psu_mask_write(0xFD409978, 0x00000010U, 0x00000010U);
 	psu_mask_write(0xFD40D978, 0x00000010U, 0x00000010U);
+
+	serdes_illcalib(3, 0, 5, 0, 1, 1, 1, 1);
 	psu_mask_write(0xFD3D001C, 0xFFFFFFFFU, 0x00000001U);
 	psu_mask_write(0xFD410010, 0x00000077U, 0x00000011U);
 	psu_mask_write(0xFD410014, 0x00000077U, 0x00000035U);
@@ -787,8 +794,7 @@ static unsigned long psu_ddr_phybringup_data(void)
 		    >> 31;
 		pll_locked &= (Xil_In32(0xFD0807E0) & 0x10000)
 		    >> 16;
-		pll_locked &= (Xil_In32(0xFD0809E0) & 0x10000)
-		    >> 16;
+		pll_locked &= (Xil_In32(0xFD0809E0) & 0x10000) >> 16;
 		pll_locked &= (Xil_In32(0xFD080BE0) & 0x10000)
 		    >> 16;
 		pll_locked &= (Xil_In32(0xFD080DE0) & 0x10000)
@@ -838,6 +844,10 @@ static unsigned long psu_ddr_phybringup_data(void)
 	while ((regval & 0x80004001) != 0x80004001)
 		regval = Xil_In32(0xFD080030);
 
+	regval = ((Xil_In32(0xFD080030) & 0x1FFF0000) >> 18);
+	if (regval != 0)
+		return 0;
+
 	prog_reg(0xFD08001CU, 0x00000018U, 0x00000003U, 0x00000000U);
 	prog_reg(0xFD08142CU, 0x00000030U, 0x00000004U, 0x00000000U);
 	prog_reg(0xFD08146CU, 0x00000030U, 0x00000004U, 0x00000000U);
@@ -860,6 +870,938 @@ static unsigned long psu_ddr_phybringup_data(void)
 	return 1;
 }
 
+static int serdes_rst_seq(u32 lane3_protocol, u32 lane3_rate,
+			  u32 lane2_protocol, u32 lane2_rate,
+			  u32 lane1_protocol, u32 lane1_rate,
+			  u32 lane0_protocol, u32 lane0_rate)
+{
+	Xil_Out32(0xFD410098, 0x00000000);
+	Xil_Out32(0xFD401010, 0x00000040);
+	Xil_Out32(0xFD405010, 0x00000040);
+	Xil_Out32(0xFD409010, 0x00000040);
+	Xil_Out32(0xFD40D010, 0x00000040);
+	Xil_Out32(0xFD402084, 0x00000080);
+	Xil_Out32(0xFD406084, 0x00000080);
+	Xil_Out32(0xFD40A084, 0x00000080);
+	Xil_Out32(0xFD40E084, 0x00000080);
+	Xil_Out32(0xFD410098, 0x00000004);
+	mask_delay(50);
+	if (lane0_rate == 1)
+		Xil_Out32(0xFD410098, 0x0000000E);
+	Xil_Out32(0xFD410098, 0x00000006);
+	if (lane0_rate == 1) {
+		Xil_Out32(0xFD40000C, 0x00000004);
+		Xil_Out32(0xFD40400C, 0x00000004);
+		Xil_Out32(0xFD40800C, 0x00000004);
+		Xil_Out32(0xFD40C00C, 0x00000004);
+		Xil_Out32(0xFD410098, 0x00000007);
+		mask_delay(400);
+		Xil_Out32(0xFD40000C, 0x0000000C);
+		Xil_Out32(0xFD40400C, 0x0000000C);
+		Xil_Out32(0xFD40800C, 0x0000000C);
+		Xil_Out32(0xFD40C00C, 0x0000000C);
+		mask_delay(15);
+		Xil_Out32(0xFD410098, 0x0000000F);
+		mask_delay(100);
+	}
+	if (lane0_protocol != 0)
+		mask_poll(0xFD4023E4, 0x00000010U);
+	if (lane1_protocol != 0)
+		mask_poll(0xFD4063E4, 0x00000010U);
+	if (lane2_protocol != 0)
+		mask_poll(0xFD40A3E4, 0x00000010U);
+	if (lane3_protocol != 0)
+		mask_poll(0xFD40E3E4, 0x00000010U);
+	mask_delay(50);
+	Xil_Out32(0xFD401010, 0x000000C0);
+	Xil_Out32(0xFD405010, 0x000000C0);
+	Xil_Out32(0xFD409010, 0x000000C0);
+	Xil_Out32(0xFD40D010, 0x000000C0);
+	Xil_Out32(0xFD401010, 0x00000080);
+	Xil_Out32(0xFD405010, 0x00000080);
+	Xil_Out32(0xFD409010, 0x00000080);
+	Xil_Out32(0xFD40D010, 0x00000080);
+
+	Xil_Out32(0xFD402084, 0x000000C0);
+	Xil_Out32(0xFD406084, 0x000000C0);
+	Xil_Out32(0xFD40A084, 0x000000C0);
+	Xil_Out32(0xFD40E084, 0x000000C0);
+	mask_delay(50);
+	Xil_Out32(0xFD402084, 0x00000080);
+	Xil_Out32(0xFD406084, 0x00000080);
+	Xil_Out32(0xFD40A084, 0x00000080);
+	Xil_Out32(0xFD40E084, 0x00000080);
+	mask_delay(50);
+	Xil_Out32(0xFD401010, 0x00000000);
+	Xil_Out32(0xFD405010, 0x00000000);
+	Xil_Out32(0xFD409010, 0x00000000);
+	Xil_Out32(0xFD40D010, 0x00000000);
+	Xil_Out32(0xFD402084, 0x00000000);
+	Xil_Out32(0xFD406084, 0x00000000);
+	Xil_Out32(0xFD40A084, 0x00000000);
+	Xil_Out32(0xFD40E084, 0x00000000);
+	mask_delay(500);
+	return 1;
+}
+
+static int serdes_bist_static_settings(u32 lane_active)
+{
+	if (lane_active == 0) {
+		Xil_Out32(0xFD403004, (Xil_In32(0xFD403004) & 0xFFFFFF1F));
+		Xil_Out32(0xFD403068, 0x1);
+		Xil_Out32(0xFD40306C, 0x1);
+		Xil_Out32(0xFD4010AC, 0x0020);
+		Xil_Out32(0xFD403008, 0x0);
+		Xil_Out32(0xFD40300C, 0xF4);
+		Xil_Out32(0xFD403010, 0x0);
+		Xil_Out32(0xFD403014, 0x0);
+		Xil_Out32(0xFD403018, 0x00);
+		Xil_Out32(0xFD40301C, 0xFB);
+		Xil_Out32(0xFD403020, 0xFF);
+		Xil_Out32(0xFD403024, 0x0);
+		Xil_Out32(0xFD403028, 0x00);
+		Xil_Out32(0xFD40302C, 0x00);
+		Xil_Out32(0xFD403030, 0x4A);
+		Xil_Out32(0xFD403034, 0x4A);
+		Xil_Out32(0xFD403038, 0x4A);
+		Xil_Out32(0xFD40303C, 0x4A);
+		Xil_Out32(0xFD403040, 0x0);
+		Xil_Out32(0xFD403044, 0x14);
+		Xil_Out32(0xFD403048, 0x02);
+		Xil_Out32(0xFD403004, (Xil_In32(0xFD403004) & 0xFFFFFF1F));
+	}
+	if (lane_active == 1) {
+		Xil_Out32(0xFD407004, (Xil_In32(0xFD407004) & 0xFFFFFF1F));
+		Xil_Out32(0xFD407068, 0x1);
+		Xil_Out32(0xFD40706C, 0x1);
+		Xil_Out32(0xFD4050AC, 0x0020);
+		Xil_Out32(0xFD407008, 0x0);
+		Xil_Out32(0xFD40700C, 0xF4);
+		Xil_Out32(0xFD407010, 0x0);
+		Xil_Out32(0xFD407014, 0x0);
+		Xil_Out32(0xFD407018, 0x00);
+		Xil_Out32(0xFD40701C, 0xFB);
+		Xil_Out32(0xFD407020, 0xFF);
+		Xil_Out32(0xFD407024, 0x0);
+		Xil_Out32(0xFD407028, 0x00);
+		Xil_Out32(0xFD40702C, 0x00);
+		Xil_Out32(0xFD407030, 0x4A);
+		Xil_Out32(0xFD407034, 0x4A);
+		Xil_Out32(0xFD407038, 0x4A);
+		Xil_Out32(0xFD40703C, 0x4A);
+		Xil_Out32(0xFD407040, 0x0);
+		Xil_Out32(0xFD407044, 0x14);
+		Xil_Out32(0xFD407048, 0x02);
+		Xil_Out32(0xFD407004, (Xil_In32(0xFD407004) & 0xFFFFFF1F));
+	}
+
+	if (lane_active == 2) {
+		Xil_Out32(0xFD40B004, (Xil_In32(0xFD40B004) & 0xFFFFFF1F));
+		Xil_Out32(0xFD40B068, 0x1);
+		Xil_Out32(0xFD40B06C, 0x1);
+		Xil_Out32(0xFD4090AC, 0x0020);
+		Xil_Out32(0xFD40B008, 0x0);
+		Xil_Out32(0xFD40B00C, 0xF4);
+		Xil_Out32(0xFD40B010, 0x0);
+		Xil_Out32(0xFD40B014, 0x0);
+		Xil_Out32(0xFD40B018, 0x00);
+		Xil_Out32(0xFD40B01C, 0xFB);
+		Xil_Out32(0xFD40B020, 0xFF);
+		Xil_Out32(0xFD40B024, 0x0);
+		Xil_Out32(0xFD40B028, 0x00);
+		Xil_Out32(0xFD40B02C, 0x00);
+		Xil_Out32(0xFD40B030, 0x4A);
+		Xil_Out32(0xFD40B034, 0x4A);
+		Xil_Out32(0xFD40B038, 0x4A);
+		Xil_Out32(0xFD40B03C, 0x4A);
+		Xil_Out32(0xFD40B040, 0x0);
+		Xil_Out32(0xFD40B044, 0x14);
+		Xil_Out32(0xFD40B048, 0x02);
+		Xil_Out32(0xFD40B004, (Xil_In32(0xFD40B004) & 0xFFFFFF1F));
+	}
+
+	if (lane_active == 3) {
+		Xil_Out32(0xFD40F004, (Xil_In32(0xFD40F004) & 0xFFFFFF1F));
+		Xil_Out32(0xFD40F068, 0x1);
+		Xil_Out32(0xFD40F06C, 0x1);
+		Xil_Out32(0xFD40D0AC, 0x0020);
+		Xil_Out32(0xFD40F008, 0x0);
+		Xil_Out32(0xFD40F00C, 0xF4);
+		Xil_Out32(0xFD40F010, 0x0);
+		Xil_Out32(0xFD40F014, 0x0);
+		Xil_Out32(0xFD40F018, 0x00);
+		Xil_Out32(0xFD40F01C, 0xFB);
+		Xil_Out32(0xFD40F020, 0xFF);
+		Xil_Out32(0xFD40F024, 0x0);
+		Xil_Out32(0xFD40F028, 0x00);
+		Xil_Out32(0xFD40F02C, 0x00);
+		Xil_Out32(0xFD40F030, 0x4A);
+		Xil_Out32(0xFD40F034, 0x4A);
+		Xil_Out32(0xFD40F038, 0x4A);
+		Xil_Out32(0xFD40F03C, 0x4A);
+		Xil_Out32(0xFD40F040, 0x0);
+		Xil_Out32(0xFD40F044, 0x14);
+		Xil_Out32(0xFD40F048, 0x02);
+		Xil_Out32(0xFD40F004, (Xil_In32(0xFD40F004) & 0xFFFFFF1F));
+	}
+	return 1;
+}
+
+static int serdes_bist_run(u32 lane_active)
+{
+	if (lane_active == 0) {
+		psu_mask_write(0xFD410044, 0x00000003U, 0x00000000U);
+		psu_mask_write(0xFD410040, 0x00000003U, 0x00000000U);
+		psu_mask_write(0xFD410038, 0x00000007U, 0x00000001U);
+		Xil_Out32(0xFD4010AC, 0x0020);
+		Xil_Out32(0xFD403004, (Xil_In32(0xFD403004) | 0x1));
+	}
+	if (lane_active == 1) {
+		psu_mask_write(0xFD410044, 0x0000000CU, 0x00000000U);
+		psu_mask_write(0xFD410040, 0x0000000CU, 0x00000000U);
+		psu_mask_write(0xFD410038, 0x00000070U, 0x00000010U);
+		Xil_Out32(0xFD4050AC, 0x0020);
+		Xil_Out32(0xFD407004, (Xil_In32(0xFD407004) | 0x1));
+	}
+	if (lane_active == 2) {
+		psu_mask_write(0xFD410044, 0x00000030U, 0x00000000U);
+		psu_mask_write(0xFD410040, 0x00000030U, 0x00000000U);
+		psu_mask_write(0xFD41003C, 0x00000007U, 0x00000001U);
+		Xil_Out32(0xFD4090AC, 0x0020);
+		Xil_Out32(0xFD40B004, (Xil_In32(0xFD40B004) | 0x1));
+	}
+	if (lane_active == 3) {
+		psu_mask_write(0xFD410040, 0x000000C0U, 0x00000000U);
+		psu_mask_write(0xFD410044, 0x000000C0U, 0x00000000U);
+		psu_mask_write(0xFD41003C, 0x00000070U, 0x00000010U);
+		Xil_Out32(0xFD40D0AC, 0x0020);
+		Xil_Out32(0xFD40F004, (Xil_In32(0xFD40F004) | 0x1));
+	}
+	mask_delay(100);
+	return 1;
+}
+
+static int serdes_bist_result(u32 lane_active)
+{
+	u32 pkt_cnt_l0, pkt_cnt_h0, err_cnt_l0, err_cnt_h0;
+	if (lane_active == 0) {
+		pkt_cnt_l0 = Xil_In32(0xFD40304C);
+		pkt_cnt_h0 = Xil_In32(0xFD403050);
+		err_cnt_l0 = Xil_In32(0xFD403054);
+		err_cnt_h0 = Xil_In32(0xFD403058);
+	}
+	if (lane_active == 1) {
+		pkt_cnt_l0 = Xil_In32(0xFD40704C);
+		pkt_cnt_h0 = Xil_In32(0xFD407050);
+		err_cnt_l0 = Xil_In32(0xFD407054);
+		err_cnt_h0 = Xil_In32(0xFD407058);
+	}
+	if (lane_active == 2) {
+		pkt_cnt_l0 = Xil_In32(0xFD40B04C);
+		pkt_cnt_h0 = Xil_In32(0xFD40B050);
+		err_cnt_l0 = Xil_In32(0xFD40B054);
+		err_cnt_h0 = Xil_In32(0xFD40B058);
+	}
+	if (lane_active == 3) {
+		pkt_cnt_l0 = Xil_In32(0xFD40F04C);
+		pkt_cnt_h0 = Xil_In32(0xFD40F050);
+		err_cnt_l0 = Xil_In32(0xFD40F054);
+		err_cnt_h0 = Xil_In32(0xFD40F058);
+	}
+	if (lane_active == 0)
+		Xil_Out32(0xFD403004, 0x0);
+	if (lane_active == 1)
+		Xil_Out32(0xFD407004, 0x0);
+	if (lane_active == 2)
+		Xil_Out32(0xFD40B004, 0x0);
+	if (lane_active == 3)
+		Xil_Out32(0xFD40F004, 0x0);
+	if ((err_cnt_l0 > 0) || (err_cnt_h0 > 0)
+	    || ((pkt_cnt_l0 == 0) && (pkt_cnt_h0 == 0)))
+		return 0;
+	return 1;
+}
+
+static int serdes_illcalib_pcie_gen1(u32 lane3_protocol, u32 lane3_rate,
+				     u32 lane2_protocol, u32 lane2_rate,
+				     u32 lane1_protocol, u32 lane1_rate,
+				     u32 lane0_protocol, u32 lane0_rate,
+				     u32 gen2_calib)
+{
+	u64 tempbistresult;
+	u32 currbistresult[4];
+	u32 prevbistresult[4];
+	u32 itercount = 0;
+	u32 ill12_val[4], ill1_val[4];
+	u32 loop = 0;
+	u32 iterresult[8];
+	u32 meancount[4];
+	u32 bistpasscount[4];
+	u32 meancountalt[4];
+	u32 meancountalt_bistpasscount[4];
+	u32 lane0_active;
+	u32 lane1_active;
+	u32 lane2_active;
+	u32 lane3_active;
+
+	lane0_active = (lane0_protocol == 1);
+	lane1_active = (lane1_protocol == 1);
+	lane2_active = (lane2_protocol == 1);
+	lane3_active = (lane3_protocol == 1);
+	for (loop = 0; loop <= 3; loop++) {
+		iterresult[loop] = 0;
+		iterresult[loop + 4] = 0;
+		meancountalt[loop] = 0;
+		meancountalt_bistpasscount[loop] = 0;
+		meancount[loop] = 0;
+		prevbistresult[loop] = 0;
+		bistpasscount[loop] = 0;
+	}
+	itercount = 0;
+	if (lane0_active)
+		serdes_bist_static_settings(0);
+	if (lane1_active)
+		serdes_bist_static_settings(1);
+	if (lane2_active)
+		serdes_bist_static_settings(2);
+	if (lane3_active)
+		serdes_bist_static_settings(3);
+	do {
+		if (gen2_calib != 1) {
+			if (lane0_active == 1)
+				ill1_val[0] = ((0x04 + itercount * 8) % 0x100);
+			if (lane0_active == 1)
+				ill12_val[0] =
+				    ((0x04 + itercount * 8) >=
+				     0x100) ? 0x10 : 0x00;
+			if (lane1_active == 1)
+				ill1_val[1] = ((0x04 + itercount * 8) % 0x100);
+			if (lane1_active == 1)
+				ill12_val[1] =
+				    ((0x04 + itercount * 8) >=
+				     0x100) ? 0x10 : 0x00;
+			if (lane2_active == 1)
+				ill1_val[2] = ((0x04 + itercount * 8) % 0x100);
+			if (lane2_active == 1)
+				ill12_val[2] =
+				    ((0x04 + itercount * 8) >=
+				     0x100) ? 0x10 : 0x00;
+			if (lane3_active == 1)
+				ill1_val[3] = ((0x04 + itercount * 8) % 0x100);
+			if (lane3_active == 1)
+				ill12_val[3] =
+				    ((0x04 + itercount * 8) >=
+				     0x100) ? 0x10 : 0x00;
+
+			if (lane0_active == 1)
+				Xil_Out32(0xFD401924, ill1_val[0]);
+			if (lane0_active == 1)
+				psu_mask_write(0xFD401990, 0x000000F0U,
+					       ill12_val[0]);
+			if (lane1_active == 1)
+				Xil_Out32(0xFD405924, ill1_val[1]);
+			if (lane1_active == 1)
+				psu_mask_write(0xFD405990, 0x000000F0U,
+					       ill12_val[1]);
+			if (lane2_active == 1)
+				Xil_Out32(0xFD409924, ill1_val[2]);
+			if (lane2_active == 1)
+				psu_mask_write(0xFD409990, 0x000000F0U,
+					       ill12_val[2]);
+			if (lane3_active == 1)
+				Xil_Out32(0xFD40D924, ill1_val[3]);
+			if (lane3_active == 1)
+				psu_mask_write(0xFD40D990, 0x000000F0U,
+					       ill12_val[3]);
+		}
+		if (gen2_calib == 1) {
+			if (lane0_active == 1)
+				ill1_val[0] = ((0x104 + itercount * 8) % 0x100);
+			if (lane0_active == 1)
+				ill12_val[0] =
+				    ((0x104 + itercount * 8) >=
+				     0x200) ? 0x02 : 0x01;
+			if (lane1_active == 1)
+				ill1_val[1] = ((0x104 + itercount * 8) % 0x100);
+			if (lane1_active == 1)
+				ill12_val[1] =
+				    ((0x104 + itercount * 8) >=
+				     0x200) ? 0x02 : 0x01;
+			if (lane2_active == 1)
+				ill1_val[2] = ((0x104 + itercount * 8) % 0x100);
+			if (lane2_active == 1)
+				ill12_val[2] =
+				    ((0x104 + itercount * 8) >=
+				     0x200) ? 0x02 : 0x01;
+			if (lane3_active == 1)
+				ill1_val[3] = ((0x104 + itercount * 8) % 0x100);
+			if (lane3_active == 1)
+				ill12_val[3] =
+				    ((0x104 + itercount * 8) >=
+				     0x200) ? 0x02 : 0x01;
+
+			if (lane0_active == 1)
+				Xil_Out32(0xFD401928, ill1_val[0]);
+			if (lane0_active == 1)
+				psu_mask_write(0xFD401990, 0x0000000FU,
+					       ill12_val[0]);
+			if (lane1_active == 1)
+				Xil_Out32(0xFD405928, ill1_val[1]);
+			if (lane1_active == 1)
+				psu_mask_write(0xFD405990, 0x0000000FU,
+					       ill12_val[1]);
+			if (lane2_active == 1)
+				Xil_Out32(0xFD409928, ill1_val[2]);
+			if (lane2_active == 1)
+				psu_mask_write(0xFD409990, 0x0000000FU,
+					       ill12_val[2]);
+			if (lane3_active == 1)
+				Xil_Out32(0xFD40D928, ill1_val[3]);
+			if (lane3_active == 1)
+				psu_mask_write(0xFD40D990, 0x0000000FU,
+					       ill12_val[3]);
+		}
+
+		if (lane0_active == 1)
+			psu_mask_write(0xFD401018, 0x00000030U, 0x00000010U);
+		if (lane1_active == 1)
+			psu_mask_write(0xFD405018, 0x00000030U, 0x00000010U);
+		if (lane2_active == 1)
+			psu_mask_write(0xFD409018, 0x00000030U, 0x00000010U);
+		if (lane3_active == 1)
+			psu_mask_write(0xFD40D018, 0x00000030U, 0x00000010U);
+		if (lane0_active == 1)
+			currbistresult[0] = 0;
+		if (lane1_active == 1)
+			currbistresult[1] = 0;
+		if (lane2_active == 1)
+			currbistresult[2] = 0;
+		if (lane3_active == 1)
+			currbistresult[3] = 0;
+		serdes_rst_seq(lane3_protocol, lane3_rate, lane2_protocol,
+			       lane2_rate, lane1_protocol, lane1_rate,
+			       lane0_protocol, lane0_rate);
+		if (lane3_active == 1)
+			serdes_bist_run(3);
+		if (lane2_active == 1)
+			serdes_bist_run(2);
+		if (lane1_active == 1)
+			serdes_bist_run(1);
+		if (lane0_active == 1)
+			serdes_bist_run(0);
+		tempbistresult = 0;
+		if (lane3_active == 1)
+			tempbistresult = tempbistresult | serdes_bist_result(3);
+		tempbistresult = tempbistresult << 1;
+		if (lane2_active == 1)
+			tempbistresult = tempbistresult | serdes_bist_result(2);
+		tempbistresult = tempbistresult << 1;
+		if (lane1_active == 1)
+			tempbistresult = tempbistresult | serdes_bist_result(1);
+		tempbistresult = tempbistresult << 1;
+		if (lane0_active == 1)
+			tempbistresult = tempbistresult | serdes_bist_result(0);
+		Xil_Out32(0xFD410098, 0x0);
+		Xil_Out32(0xFD410098, 0x2);
+
+		if (itercount < 32) {
+			iterresult[0] =
+			    ((iterresult[0] << 1) |
+			     ((tempbistresult & 0x1) == 0x1));
+			iterresult[1] =
+			    ((iterresult[1] << 1) |
+			     ((tempbistresult & 0x2) == 0x2));
+			iterresult[2] =
+			    ((iterresult[2] << 1) |
+			     ((tempbistresult & 0x4) == 0x4));
+			iterresult[3] =
+			    ((iterresult[3] << 1) |
+			     ((tempbistresult & 0x8) == 0x8));
+		} else {
+			iterresult[4] =
+			    ((iterresult[4] << 1) |
+			     ((tempbistresult & 0x1) == 0x1));
+			iterresult[5] =
+			    ((iterresult[5] << 1) |
+			     ((tempbistresult & 0x2) == 0x2));
+			iterresult[6] =
+			    ((iterresult[6] << 1) |
+			     ((tempbistresult & 0x4) == 0x4));
+			iterresult[7] =
+			    ((iterresult[7] << 1) |
+			     ((tempbistresult & 0x8) == 0x8));
+		}
+		currbistresult[0] =
+		    currbistresult[0] | ((tempbistresult & 0x1) == 1);
+		currbistresult[1] =
+		    currbistresult[1] | ((tempbistresult & 0x2) == 0x2);
+		currbistresult[2] =
+		    currbistresult[2] | ((tempbistresult & 0x4) == 0x4);
+		currbistresult[3] =
+		    currbistresult[3] | ((tempbistresult & 0x8) == 0x8);
+
+		for (loop = 0; loop <= 3; loop++) {
+			if ((currbistresult[loop] == 1)
+			    && (prevbistresult[loop] == 1))
+				bistpasscount[loop] = bistpasscount[loop] + 1;
+			if ((bistpasscount[loop] < 4)
+			    && (currbistresult[loop] == 0) && (itercount > 2)) {
+				if (meancountalt_bistpasscount[loop] <
+				    bistpasscount[loop]) {
+					meancountalt_bistpasscount[loop] =
+					    bistpasscount[loop];
+					meancountalt[loop] =
+					    ((itercount - 1) -
+					     ((bistpasscount[loop] + 1) / 2));
+				}
+				bistpasscount[loop] = 0;
+			}
+			if ((meancount[loop] == 0) && (bistpasscount[loop] >= 4)
+			    && ((currbistresult[loop] == 0)
+				|| (itercount == 63))
+			    && (prevbistresult[loop] == 1))
+				meancount[loop] =
+				    (itercount - 1) -
+				    ((bistpasscount[loop] + 1) / 2);
+			prevbistresult[loop] = currbistresult[loop];
+		}
+	} while (++itercount < 64);
+
+	for (loop = 0; loop <= 3; loop++) {
+		if ((lane0_active == 0) && (loop == 0))
+			continue;
+		if ((lane1_active == 0) && (loop == 1))
+			continue;
+		if ((lane2_active == 0) && (loop == 2))
+			continue;
+		if ((lane3_active == 0) && (loop == 3))
+			continue;
+
+		if (meancount[loop] == 0)
+			meancount[loop] = meancountalt[loop];
+
+		if (gen2_calib != 1) {
+			ill1_val[loop] = ((0x04 + meancount[loop] * 8) % 0x100);
+			ill12_val[loop] =
+			    ((0x04 + meancount[loop] * 8) >=
+			     0x100) ? 0x10 : 0x00;
+			Xil_Out32(0xFFFE0000 + loop * 4, iterresult[loop]);
+			Xil_Out32(0xFFFE0010 + loop * 4, iterresult[loop + 4]);
+			Xil_Out32(0xFFFE0020 + loop * 4, bistpasscount[loop]);
+			Xil_Out32(0xFFFE0030 + loop * 4, meancount[loop]);
+		}
+		if (gen2_calib == 1) {
+			ill1_val[loop] =
+			    ((0x104 + meancount[loop] * 8) % 0x100);
+			ill12_val[loop] =
+			    ((0x104 + meancount[loop] * 8) >=
+			     0x200) ? 0x02 : 0x01;
+			Xil_Out32(0xFFFE0040 + loop * 4, iterresult[loop]);
+			Xil_Out32(0xFFFE0050 + loop * 4, iterresult[loop + 4]);
+			Xil_Out32(0xFFFE0060 + loop * 4, bistpasscount[loop]);
+			Xil_Out32(0xFFFE0070 + loop * 4, meancount[loop]);
+		}
+	}
+	if (gen2_calib != 1) {
+		if (lane0_active == 1)
+			Xil_Out32(0xFD401924, ill1_val[0]);
+		if (lane0_active == 1)
+			psu_mask_write(0xFD401990, 0x000000F0U, ill12_val[0]);
+		if (lane1_active == 1)
+			Xil_Out32(0xFD405924, ill1_val[1]);
+		if (lane1_active == 1)
+			psu_mask_write(0xFD405990, 0x000000F0U, ill12_val[1]);
+		if (lane2_active == 1)
+			Xil_Out32(0xFD409924, ill1_val[2]);
+		if (lane2_active == 1)
+			psu_mask_write(0xFD409990, 0x000000F0U, ill12_val[2]);
+		if (lane3_active == 1)
+			Xil_Out32(0xFD40D924, ill1_val[3]);
+		if (lane3_active == 1)
+			psu_mask_write(0xFD40D990, 0x000000F0U, ill12_val[3]);
+	}
+	if (gen2_calib == 1) {
+		if (lane0_active == 1)
+			Xil_Out32(0xFD401928, ill1_val[0]);
+		if (lane0_active == 1)
+			psu_mask_write(0xFD401990, 0x0000000FU, ill12_val[0]);
+		if (lane1_active == 1)
+			Xil_Out32(0xFD405928, ill1_val[1]);
+		if (lane1_active == 1)
+			psu_mask_write(0xFD405990, 0x0000000FU, ill12_val[1]);
+		if (lane2_active == 1)
+			Xil_Out32(0xFD409928, ill1_val[2]);
+		if (lane2_active == 1)
+			psu_mask_write(0xFD409990, 0x0000000FU, ill12_val[2]);
+		if (lane3_active == 1)
+			Xil_Out32(0xFD40D928, ill1_val[3]);
+		if (lane3_active == 1)
+			psu_mask_write(0xFD40D990, 0x0000000FU, ill12_val[3]);
+	}
+
+	if (lane0_active == 1)
+		psu_mask_write(0xFD401018, 0x00000030U, 0x00000000U);
+	if (lane1_active == 1)
+		psu_mask_write(0xFD405018, 0x00000030U, 0x00000000U);
+	if (lane2_active == 1)
+		psu_mask_write(0xFD409018, 0x00000030U, 0x00000000U);
+	if (lane3_active == 1)
+		psu_mask_write(0xFD40D018, 0x00000030U, 0x00000000U);
+
+	Xil_Out32(0xFD410098, 0);
+	if (lane0_active == 1) {
+		Xil_Out32(0xFD403004, 0);
+		Xil_Out32(0xFD403008, 0);
+		Xil_Out32(0xFD40300C, 0);
+		Xil_Out32(0xFD403010, 0);
+		Xil_Out32(0xFD403014, 0);
+		Xil_Out32(0xFD403018, 0);
+		Xil_Out32(0xFD40301C, 0);
+		Xil_Out32(0xFD403020, 0);
+		Xil_Out32(0xFD403024, 0);
+		Xil_Out32(0xFD403028, 0);
+		Xil_Out32(0xFD40302C, 0);
+		Xil_Out32(0xFD403030, 0);
+		Xil_Out32(0xFD403034, 0);
+		Xil_Out32(0xFD403038, 0);
+		Xil_Out32(0xFD40303C, 0);
+		Xil_Out32(0xFD403040, 0);
+		Xil_Out32(0xFD403044, 0);
+		Xil_Out32(0xFD403048, 0);
+		Xil_Out32(0xFD40304C, 0);
+		Xil_Out32(0xFD403050, 0);
+		Xil_Out32(0xFD403054, 0);
+		Xil_Out32(0xFD403058, 0);
+		Xil_Out32(0xFD403068, 1);
+		Xil_Out32(0xFD40306C, 0);
+		Xil_Out32(0xFD4010AC, 0);
+		psu_mask_write(0xFD410044, 0x00000003U, 0x00000001U);
+		psu_mask_write(0xFD410040, 0x00000003U, 0x00000001U);
+		psu_mask_write(0xFD410038, 0x00000007U, 0x00000000U);
+	}
+	if (lane1_active == 1) {
+		Xil_Out32(0xFD407004, 0);
+		Xil_Out32(0xFD407008, 0);
+		Xil_Out32(0xFD40700C, 0);
+		Xil_Out32(0xFD407010, 0);
+		Xil_Out32(0xFD407014, 0);
+		Xil_Out32(0xFD407018, 0);
+		Xil_Out32(0xFD40701C, 0);
+		Xil_Out32(0xFD407020, 0);
+		Xil_Out32(0xFD407024, 0);
+		Xil_Out32(0xFD407028, 0);
+		Xil_Out32(0xFD40702C, 0);
+		Xil_Out32(0xFD407030, 0);
+		Xil_Out32(0xFD407034, 0);
+		Xil_Out32(0xFD407038, 0);
+		Xil_Out32(0xFD40703C, 0);
+		Xil_Out32(0xFD407040, 0);
+		Xil_Out32(0xFD407044, 0);
+		Xil_Out32(0xFD407048, 0);
+		Xil_Out32(0xFD40704C, 0);
+		Xil_Out32(0xFD407050, 0);
+		Xil_Out32(0xFD407054, 0);
+		Xil_Out32(0xFD407058, 0);
+		Xil_Out32(0xFD407068, 1);
+		Xil_Out32(0xFD40706C, 0);
+		Xil_Out32(0xFD4050AC, 0);
+		psu_mask_write(0xFD410044, 0x0000000CU, 0x00000004U);
+		psu_mask_write(0xFD410040, 0x0000000CU, 0x00000004U);
+		psu_mask_write(0xFD410038, 0x00000070U, 0x00000000U);
+	}
+	if (lane2_active == 1) {
+		Xil_Out32(0xFD40B004, 0);
+		Xil_Out32(0xFD40B008, 0);
+		Xil_Out32(0xFD40B00C, 0);
+		Xil_Out32(0xFD40B010, 0);
+		Xil_Out32(0xFD40B014, 0);
+		Xil_Out32(0xFD40B018, 0);
+		Xil_Out32(0xFD40B01C, 0);
+		Xil_Out32(0xFD40B020, 0);
+		Xil_Out32(0xFD40B024, 0);
+		Xil_Out32(0xFD40B028, 0);
+		Xil_Out32(0xFD40B02C, 0);
+		Xil_Out32(0xFD40B030, 0);
+		Xil_Out32(0xFD40B034, 0);
+		Xil_Out32(0xFD40B038, 0);
+		Xil_Out32(0xFD40B03C, 0);
+		Xil_Out32(0xFD40B040, 0);
+		Xil_Out32(0xFD40B044, 0);
+		Xil_Out32(0xFD40B048, 0);
+		Xil_Out32(0xFD40B04C, 0);
+		Xil_Out32(0xFD40B050, 0);
+		Xil_Out32(0xFD40B054, 0);
+		Xil_Out32(0xFD40B058, 0);
+		Xil_Out32(0xFD40B068, 1);
+		Xil_Out32(0xFD40B06C, 0);
+		Xil_Out32(0xFD4090AC, 0);
+		psu_mask_write(0xFD410044, 0x00000030U, 0x00000010U);
+		psu_mask_write(0xFD410040, 0x00000030U, 0x00000010U);
+		psu_mask_write(0xFD41003C, 0x00000007U, 0x00000000U);
+	}
+	if (lane3_active == 1) {
+		Xil_Out32(0xFD40F004, 0);
+		Xil_Out32(0xFD40F008, 0);
+		Xil_Out32(0xFD40F00C, 0);
+		Xil_Out32(0xFD40F010, 0);
+		Xil_Out32(0xFD40F014, 0);
+		Xil_Out32(0xFD40F018, 0);
+		Xil_Out32(0xFD40F01C, 0);
+		Xil_Out32(0xFD40F020, 0);
+		Xil_Out32(0xFD40F024, 0);
+		Xil_Out32(0xFD40F028, 0);
+		Xil_Out32(0xFD40F02C, 0);
+		Xil_Out32(0xFD40F030, 0);
+		Xil_Out32(0xFD40F034, 0);
+		Xil_Out32(0xFD40F038, 0);
+		Xil_Out32(0xFD40F03C, 0);
+		Xil_Out32(0xFD40F040, 0);
+		Xil_Out32(0xFD40F044, 0);
+		Xil_Out32(0xFD40F048, 0);
+		Xil_Out32(0xFD40F04C, 0);
+		Xil_Out32(0xFD40F050, 0);
+		Xil_Out32(0xFD40F054, 0);
+		Xil_Out32(0xFD40F058, 0);
+		Xil_Out32(0xFD40F068, 1);
+		Xil_Out32(0xFD40F06C, 0);
+		Xil_Out32(0xFD40D0AC, 0);
+		psu_mask_write(0xFD410044, 0x000000C0U, 0x00000040U);
+		psu_mask_write(0xFD410040, 0x000000C0U, 0x00000040U);
+		psu_mask_write(0xFD41003C, 0x00000070U, 0x00000000U);
+	}
+	return 1;
+}
+
+static int serdes_illcalib(u32 lane3_protocol, u32 lane3_rate,
+			   u32 lane2_protocol, u32 lane2_rate,
+			   u32 lane1_protocol, u32 lane1_rate,
+			   u32 lane0_protocol, u32 lane0_rate)
+
+{
+	unsigned int rdata = 0;
+	unsigned int sata_gen2 = 1;
+	unsigned int temp_ill12 = 0;
+	unsigned int temp_PLL_REF_SEL_OFFSET;
+	unsigned int temp_TM_IQ_ILL1;
+	unsigned int temp_TM_E_ILL1;
+	unsigned int temp_tx_dig_tm_61;
+	unsigned int temp_tm_dig_6;
+	unsigned int temp_pll_fbdiv_frac_3_msb_offset;
+
+	if ((lane0_protocol == 2) || (lane0_protocol == 1)) {
+		Xil_Out32(0xFD401910, 0xF3);
+		Xil_Out32(0xFD40193C, 0xF3);
+		Xil_Out32(0xFD401914, 0xF3);
+		Xil_Out32(0xFD401940, 0xF3);
+	}
+	if ((lane1_protocol == 2) || (lane1_protocol == 1)) {
+		Xil_Out32(0xFD405910, 0xF3);
+		Xil_Out32(0xFD40593C, 0xF3);
+		Xil_Out32(0xFD405914, 0xF3);
+		Xil_Out32(0xFD405940, 0xF3);
+	}
+	if ((lane2_protocol == 2) || (lane2_protocol == 1)) {
+		Xil_Out32(0xFD409910, 0xF3);
+		Xil_Out32(0xFD40993C, 0xF3);
+		Xil_Out32(0xFD409914, 0xF3);
+		Xil_Out32(0xFD409940, 0xF3);
+	}
+	if ((lane3_protocol == 2) || (lane3_protocol == 1)) {
+		Xil_Out32(0xFD40D910, 0xF3);
+		Xil_Out32(0xFD40D93C, 0xF3);
+		Xil_Out32(0xFD40D914, 0xF3);
+		Xil_Out32(0xFD40D940, 0xF3);
+	}
+
+	if (sata_gen2 == 1) {
+		if (lane0_protocol == 2) {
+			temp_pll_fbdiv_frac_3_msb_offset = Xil_In32(0xFD402360);
+			Xil_Out32(0xFD402360, 0x0);
+			temp_PLL_REF_SEL_OFFSET = Xil_In32(0xFD410000);
+			psu_mask_write(0xFD410000, 0x0000001FU, 0x0000000DU);
+			temp_TM_IQ_ILL1 = Xil_In32(0xFD4018F8);
+			temp_TM_E_ILL1 = Xil_In32(0xFD401924);
+			Xil_Out32(0xFD4018F8, 0x78);
+			temp_tx_dig_tm_61 = Xil_In32(0xFD4000F4);
+			temp_tm_dig_6 = Xil_In32(0xFD40106C);
+			psu_mask_write(0xFD4000F4, 0x0000000BU, 0x00000000U);
+			psu_mask_write(0xFD40106C, 0x0000000FU, 0x00000000U);
+			temp_ill12 = Xil_In32(0xFD401990) & 0xF0;
+
+			serdes_illcalib_pcie_gen1(0, 0, 0, 0, 0, 0, 1, 0, 0);
+
+			Xil_Out32(0xFD402360, temp_pll_fbdiv_frac_3_msb_offset);
+			Xil_Out32(0xFD41000C, temp_PLL_REF_SEL_OFFSET);
+			Xil_Out32(0xFD4018F8, temp_TM_IQ_ILL1);
+			Xil_Out32(0xFD4000F4, temp_tx_dig_tm_61);
+			Xil_Out32(0xFD40106C, temp_tm_dig_6);
+			Xil_Out32(0xFD401928, Xil_In32(0xFD401924));
+			temp_ill12 =
+			    temp_ill12 | (Xil_In32(0xFD401990) >> 4 & 0xF);
+			Xil_Out32(0xFD401990, temp_ill12);
+			Xil_Out32(0xFD401924, temp_TM_E_ILL1);
+		}
+		if (lane1_protocol == 2) {
+			temp_pll_fbdiv_frac_3_msb_offset = Xil_In32(0xFD406360);
+			Xil_Out32(0xFD406360, 0x0);
+			temp_PLL_REF_SEL_OFFSET = Xil_In32(0xFD410004);
+			psu_mask_write(0xFD410004, 0x0000001FU, 0x0000000DU);
+			temp_TM_IQ_ILL1 = Xil_In32(0xFD4058F8);
+			temp_TM_E_ILL1 = Xil_In32(0xFD405924);
+			Xil_Out32(0xFD4058F8, 0x78);
+			temp_tx_dig_tm_61 = Xil_In32(0xFD4040F4);
+			temp_tm_dig_6 = Xil_In32(0xFD40506C);
+			psu_mask_write(0xFD4040F4, 0x0000000BU, 0x00000000U);
+			psu_mask_write(0xFD40506C, 0x0000000FU, 0x00000000U);
+			temp_ill12 = Xil_In32(0xFD405990) & 0xF0;
+
+			serdes_illcalib_pcie_gen1(0, 0, 0, 0, 1, 0, 0, 0, 0);
+
+			Xil_Out32(0xFD406360, temp_pll_fbdiv_frac_3_msb_offset);
+			Xil_Out32(0xFD41000C, temp_PLL_REF_SEL_OFFSET);
+			Xil_Out32(0xFD4058F8, temp_TM_IQ_ILL1);
+			Xil_Out32(0xFD4040F4, temp_tx_dig_tm_61);
+			Xil_Out32(0xFD40506C, temp_tm_dig_6);
+			Xil_Out32(0xFD405928, Xil_In32(0xFD405924));
+			temp_ill12 =
+			    temp_ill12 | (Xil_In32(0xFD405990) >> 4 & 0xF);
+			Xil_Out32(0xFD405990, temp_ill12);
+			Xil_Out32(0xFD405924, temp_TM_E_ILL1);
+		}
+		if (lane2_protocol == 2) {
+			temp_pll_fbdiv_frac_3_msb_offset = Xil_In32(0xFD40A360);
+			Xil_Out32(0xFD40A360, 0x0);
+			temp_PLL_REF_SEL_OFFSET = Xil_In32(0xFD410008);
+			psu_mask_write(0xFD410008, 0x0000001FU, 0x0000000DU);
+			temp_TM_IQ_ILL1 = Xil_In32(0xFD4098F8);
+			temp_TM_E_ILL1 = Xil_In32(0xFD409924);
+			Xil_Out32(0xFD4098F8, 0x78);
+			temp_tx_dig_tm_61 = Xil_In32(0xFD4080F4);
+			temp_tm_dig_6 = Xil_In32(0xFD40906C);
+			psu_mask_write(0xFD4080F4, 0x0000000BU, 0x00000000U);
+			psu_mask_write(0xFD40906C, 0x0000000FU, 0x00000000U);
+			temp_ill12 = Xil_In32(0xFD409990) & 0xF0;
+
+			serdes_illcalib_pcie_gen1(0, 0, 1, 0, 0, 0, 0, 0, 0);
+
+			Xil_Out32(0xFD40A360, temp_pll_fbdiv_frac_3_msb_offset);
+			Xil_Out32(0xFD41000C, temp_PLL_REF_SEL_OFFSET);
+			Xil_Out32(0xFD4098F8, temp_TM_IQ_ILL1);
+			Xil_Out32(0xFD4080F4, temp_tx_dig_tm_61);
+			Xil_Out32(0xFD40906C, temp_tm_dig_6);
+			Xil_Out32(0xFD409928, Xil_In32(0xFD409924));
+			temp_ill12 =
+			    temp_ill12 | (Xil_In32(0xFD409990) >> 4 & 0xF);
+			Xil_Out32(0xFD409990, temp_ill12);
+			Xil_Out32(0xFD409924, temp_TM_E_ILL1);
+		}
+		if (lane3_protocol == 2) {
+			temp_pll_fbdiv_frac_3_msb_offset = Xil_In32(0xFD40E360);
+			Xil_Out32(0xFD40E360, 0x0);
+			temp_PLL_REF_SEL_OFFSET = Xil_In32(0xFD41000C);
+			psu_mask_write(0xFD41000C, 0x0000001FU, 0x0000000DU);
+			temp_TM_IQ_ILL1 = Xil_In32(0xFD40D8F8);
+			temp_TM_E_ILL1 = Xil_In32(0xFD40D924);
+			Xil_Out32(0xFD40D8F8, 0x78);
+			temp_tx_dig_tm_61 = Xil_In32(0xFD40C0F4);
+			temp_tm_dig_6 = Xil_In32(0xFD40D06C);
+			psu_mask_write(0xFD40C0F4, 0x0000000BU, 0x00000000U);
+			psu_mask_write(0xFD40D06C, 0x0000000FU, 0x00000000U);
+			temp_ill12 = Xil_In32(0xFD40D990) & 0xF0;
+
+			serdes_illcalib_pcie_gen1(1, 0, 0, 0, 0, 0, 0, 0, 0);
+
+			Xil_Out32(0xFD40E360, temp_pll_fbdiv_frac_3_msb_offset);
+			Xil_Out32(0xFD41000C, temp_PLL_REF_SEL_OFFSET);
+			Xil_Out32(0xFD40D8F8, temp_TM_IQ_ILL1);
+			Xil_Out32(0xFD40C0F4, temp_tx_dig_tm_61);
+			Xil_Out32(0xFD40D06C, temp_tm_dig_6);
+			Xil_Out32(0xFD40D928, Xil_In32(0xFD40D924));
+			temp_ill12 =
+			    temp_ill12 | (Xil_In32(0xFD40D990) >> 4 & 0xF);
+			Xil_Out32(0xFD40D990, temp_ill12);
+			Xil_Out32(0xFD40D924, temp_TM_E_ILL1);
+		}
+		rdata = Xil_In32(0xFD410098);
+		rdata = (rdata & 0xDF);
+		Xil_Out32(0xFD410098, rdata);
+	}
+
+	if ((lane0_protocol == 2) && (lane0_rate == 3)) {
+		psu_mask_write(0xFD40198C, 0x000000F0U, 0x00000020U);
+		psu_mask_write(0xFD40192C, 0x000000FFU, 0x00000094U);
+	}
+	if ((lane1_protocol == 2) && (lane1_rate == 3)) {
+		psu_mask_write(0xFD40598C, 0x000000F0U, 0x00000020U);
+		psu_mask_write(0xFD40592C, 0x000000FFU, 0x00000094U);
+	}
+	if ((lane2_protocol == 2) && (lane2_rate == 3)) {
+		psu_mask_write(0xFD40998C, 0x000000F0U, 0x00000020U);
+		psu_mask_write(0xFD40992C, 0x000000FFU, 0x00000094U);
+	}
+	if ((lane3_protocol == 2) && (lane3_rate == 3)) {
+		psu_mask_write(0xFD40D98C, 0x000000F0U, 0x00000020U);
+		psu_mask_write(0xFD40D92C, 0x000000FFU, 0x00000094U);
+	}
+
+	if (lane0_protocol == 1) {
+		if (lane0_rate == 0) {
+			serdes_illcalib_pcie_gen1(lane3_protocol, lane3_rate,
+						  lane2_protocol, lane2_rate,
+						  lane1_protocol, lane1_rate,
+						  lane0_protocol, 0, 0);
+		} else {
+			serdes_illcalib_pcie_gen1(lane3_protocol, lane3_rate,
+						  lane2_protocol, lane2_rate,
+						  lane1_protocol, lane1_rate,
+						  lane0_protocol, 0, 0);
+			serdes_illcalib_pcie_gen1(lane3_protocol, lane3_rate,
+						  lane2_protocol, lane2_rate,
+						  lane1_protocol, lane1_rate,
+						  lane0_protocol, lane0_rate,
+						  1);
+		}
+	}
+
+	if (lane0_protocol == 3)
+		Xil_Out32(0xFD401914, 0xF3);
+	if (lane0_protocol == 3)
+		Xil_Out32(0xFD401940, 0xF3);
+	if (lane0_protocol == 3)
+		Xil_Out32(0xFD401990, 0x20);
+	if (lane0_protocol == 3)
+		Xil_Out32(0xFD401924, 0x37);
+
+	if (lane1_protocol == 3)
+		Xil_Out32(0xFD405914, 0xF3);
+	if (lane1_protocol == 3)
+		Xil_Out32(0xFD405940, 0xF3);
+	if (lane1_protocol == 3)
+		Xil_Out32(0xFD405990, 0x20);
+	if (lane1_protocol == 3)
+		Xil_Out32(0xFD405924, 0x37);
+
+	if (lane2_protocol == 3)
+		Xil_Out32(0xFD409914, 0xF3);
+	if (lane2_protocol == 3)
+		Xil_Out32(0xFD409940, 0xF3);
+	if (lane2_protocol == 3)
+		Xil_Out32(0xFD409990, 0x20);
+	if (lane2_protocol == 3)
+		Xil_Out32(0xFD409924, 0x37);
+
+	if (lane3_protocol == 3)
+		Xil_Out32(0xFD40D914, 0xF3);
+	if (lane3_protocol == 3)
+		Xil_Out32(0xFD40D940, 0xF3);
+	if (lane3_protocol == 3)
+		Xil_Out32(0xFD40D990, 0x20);
+	if (lane3_protocol == 3)
+		Xil_Out32(0xFD40D924, 0x37);
+
+	return 1;
+}
+
 static int serdes_enb_coarse_saturation(void)
 {
 	Xil_Out32(0xFD402094, 0x00000010);
diff --git a/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.h b/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.h
index 86e92c4b0a..adbc3bd47f 100644
--- a/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.h
+++ b/board/topic/zynqmp/zynqmp-topic-miamiplusmp/psu_init_gpl.h
@@ -1,6 +1,6 @@
 /******************************************************************************
 *
-* Copyright (C) 2010-2019 <Xilinx Inc.>
+* Copyright (C) 2010-2020 <Xilinx Inc.>
 * 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
@@ -31163,8 +31163,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_SHIFT           12
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_MASK            0x00001000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_SHIFT           14
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_0_MASK            0x00004000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31173,8 +31173,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_SHIFT           13
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_MASK            0x00002000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_SHIFT           15
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_1_MASK            0x00008000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31183,8 +31183,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_SHIFT           14
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_MASK            0x00004000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_SHIFT           16
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_2_MASK            0x00010000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31193,8 +31193,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_SHIFT           15
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_MASK            0x00008000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_SHIFT           17
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_3_MASK            0x00020000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31203,8 +31203,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_SHIFT           16
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_MASK            0x00010000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_SHIFT           18
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_4_MASK            0x00040000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31213,8 +31213,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_SHIFT           17
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_MASK            0x00020000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_SHIFT           19
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_5_MASK            0x00080000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31223,8 +31223,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_SHIFT           18
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_MASK            0x00040000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_SHIFT           20
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_6_MASK            0x00100000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31233,8 +31233,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_SHIFT           19
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_MASK            0x00080000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_SHIFT           21
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_7_MASK            0x00200000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31243,8 +31243,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_SHIFT           20
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_MASK            0x00100000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_SHIFT           22
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_8_MASK            0x00400000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31253,8 +31253,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_DEFVAL          
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_SHIFT           21
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_MASK            0x00200000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_SHIFT           23
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_9_MASK            0x00800000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31263,8 +31263,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_SHIFT          22
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_MASK           0x00400000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_SHIFT          24
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_10_MASK           0x01000000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31273,8 +31273,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_SHIFT          23
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_MASK           0x00800000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_SHIFT          25
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_11_MASK           0x02000000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31283,8 +31283,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_SHIFT          24
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_MASK           0x01000000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_SHIFT          0
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_12_MASK           0x00000001U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31293,8 +31293,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_SHIFT          25
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_MASK           0x02000000U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_SHIFT          1
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_13_MASK           0x00000002U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31303,8 +31303,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_SHIFT          0
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_MASK           0x00000001U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_SHIFT          2
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_14_MASK           0x00000004U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31313,8 +31313,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_SHIFT          1
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_MASK           0x00000002U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_SHIFT          3
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_15_MASK           0x00000008U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31323,8 +31323,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_SHIFT          2
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_MASK           0x00000004U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_SHIFT          4
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_16_MASK           0x00000010U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31333,8 +31333,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_SHIFT          3
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_MASK           0x00000008U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_SHIFT          5
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_17_MASK           0x00000020U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31343,8 +31343,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_SHIFT          4
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_MASK           0x00000010U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_SHIFT          6
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_18_MASK           0x00000040U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31353,8 +31353,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_SHIFT          5
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_MASK           0x00000020U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_SHIFT          7
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_19_MASK           0x00000080U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31363,8 +31363,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_SHIFT          6
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_MASK           0x00000040U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_SHIFT          8
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_20_MASK           0x00000100U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31373,8 +31373,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_SHIFT          7
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_MASK           0x00000080U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_SHIFT          9
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_21_MASK           0x00000200U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31383,8 +31383,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_SHIFT          8
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_MASK           0x00000100U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_SHIFT          10
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_22_MASK           0x00000400U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31393,8 +31393,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_SHIFT          9
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_MASK           0x00000200U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_SHIFT          11
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_23_MASK           0x00000800U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31403,8 +31403,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_SHIFT          10
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_MASK           0x00000400U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_SHIFT          12
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_24_MASK           0x00001000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
@@ -31413,8 +31413,8 @@
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_SHIFT 
 #undef IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_MASK 
 #define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_DEFVAL         
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_SHIFT          11
-#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_MASK           0x00000800U
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_SHIFT          13
+#define IOU_SLCR_BANK1_CTRL5_PULL_ENABLE_BIT_25_MASK           0x00002000U
 
 /*
 * Each bit applies to a single IO. Bit 0 for MIO[26].
-- 
2.17.1

