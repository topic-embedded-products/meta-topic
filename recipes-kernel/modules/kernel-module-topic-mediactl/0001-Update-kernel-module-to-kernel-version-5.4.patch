From d54ceaef5a2bae74fbe18f2fab2c92513715e403 Mon Sep 17 00:00:00 2001
From: Marc Brakels <marc.brakels@topic.nl>
Date: Tue, 12 Jan 2021 15:55:27 +0100
Subject: [PATCH] Update kernel module to kernel version 5.4

---
 topic-mediactl.c | 227 ++++++++++++++++++++++++-----------------------
 1 file changed, 115 insertions(+), 112 deletions(-)

diff --git a/topic-mediactl.c b/topic-mediactl.c
index 15f5002..30768d7 100644
--- a/topic-mediactl.c
+++ b/topic-mediactl.c
@@ -48,19 +48,16 @@ struct xvip_composite_device {
 
 /**
  * struct xvip_graph_entity - Entity in the video graph
- * @list: list entry in a graph entities list
- * @node: the entity's DT node
- * @entity: media entity, from the corresponding V4L2 subdev
  * @asd: subdev asynchronous registration information
+ * @entity: media entity, from the corresponding V4L2 subdev
  * @subdev: V4L2 subdev
  * @streaming: status of the V4L2 subdev if streaming or not
  */
 struct xvip_graph_entity {
-	struct list_head list;
-	struct device_node *node;
+	struct v4l2_async_subdev asd;
 	struct media_entity *entity;
 
-	struct v4l2_async_subdev asd;
+	
 	struct v4l2_subdev *subdev;
 	bool streaming;
 };
@@ -68,24 +65,51 @@ struct xvip_graph_entity {
 static struct xvip_composite_device *g_xdev;
 static int indication = 0;
 
+
+static inline struct xvip_graph_entity *
+to_xvip_entity(struct v4l2_async_subdev *asd)
+{
+	return container_of(asd, struct xvip_graph_entity, asd);
+}
+
+
 /* -----------------------------------------------------------------------------
  * Graph Management
  */
-
+ 
 static struct xvip_graph_entity *
 xvip_graph_find_entity(struct xvip_composite_device *xdev,
-		       const struct device_node *node)
+		       const struct fwnode_handle *fwnode)
 {
 	struct xvip_graph_entity *entity;
+	struct v4l2_async_subdev *asd;
 
-	list_for_each_entry(entity, &xdev->entities, list) {
-		if (entity->node == node)
+	list_for_each_entry(asd, &xdev->notifier.asd_list, asd_list) {
+		entity = to_xvip_entity(asd);
+		if (entity->asd.match.fwnode == fwnode)
 			return entity;
 	}
 
 	return NULL;
 }
 
+static struct xvip_graph_entity *
+xvip_graph_find_entity_from_media(struct xvip_composite_device *xdev,
+				  struct media_entity *entity)
+{
+	struct xvip_graph_entity *xvip_entity;
+	struct v4l2_async_subdev *asd;
+
+	list_for_each_entry(asd, &xdev->notifier.asd_list, asd_list) {
+		xvip_entity = to_xvip_entity(asd);
+		if (xvip_entity->entity == entity)
+			return xvip_entity;
+	}
+
+	return NULL;
+}
+
+
 static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 				struct xvip_graph_entity *entity)
 {
@@ -96,7 +120,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 	struct media_pad *remote_pad;
 	struct xvip_graph_entity *ent;
 	struct v4l2_fwnode_link link;
-	struct device_node *ep = NULL;
+	struct fwnode_handle *ep = NULL;
 	int ret = 0;
 
 	//dev_dbg(xdev->dev, "creating links for entity (%s)\n", local->name);
@@ -111,13 +135,14 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 
 	while (1) {
 		/* Get the next endpoint and parse its link. */
-		ep = of_graph_get_next_endpoint(entity->node, ep);
+		ep = fwnode_graph_get_next_endpoint(entity->asd.match.fwnode,
+						    ep);
 		if (ep == NULL)
 			break;
 
 		//dev_dbg(xdev->dev, "processing endpoint %pOF\n", ep);
 
-		ret = v4l2_fwnode_parse_link(of_fwnode_handle(ep), &link);
+		ret = v4l2_fwnode_parse_link(ep, &link);
 		if (ret < 0) {
 			dev_err(xdev->dev, "failed to parse link for %pOF\n",
 				ep);
@@ -130,7 +155,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		if (link.local_port >= local->num_pads) {
 			dev_err(xdev->dev, "invalid port number %u for %pOF\n",
 				link.local_port,
-				to_of_node(link.local_node));
+				link.local_node);
 			v4l2_fwnode_put_link(&link);
 			ret = -EINVAL;
 			break;
@@ -156,11 +181,10 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		}
 
 		/* Find the remote entity. */
-		ent = xvip_graph_find_entity(xdev,
-					     to_of_node(link.remote_node));
+		ent = xvip_graph_find_entity(xdev, link.remote_node);
 		if (ent == NULL) {
-			dev_err(xdev->dev, "no entity found for %pOF\n",
-				to_of_node(link.remote_node));
+			dev_err(xdev->dev, "no entity found for %p\n",
+				link.remote_node);
 			v4l2_fwnode_put_link(&link);
 			ret = -ENODEV;
 			break;
@@ -170,7 +194,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 
 		if (link.remote_port >= remote->num_pads) {
 			dev_err(xdev->dev, "invalid port number %u on %pOF\n",
-				link.remote_port, to_of_node(link.remote_node));
+				link.remote_port, link.remote_node);
 			v4l2_fwnode_put_link(&link);
 			ret = -EINVAL;
 			break;
@@ -202,58 +226,49 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 
 
 /**
- * xvip_subdev_set_streaming - Find and update streaming status of subdev
+ * xvip_graph_entity_set_streaming - Update the streaming status
  * @xdev: Composite video device
- * @subdev: V4L2 sub-device
+ * @entity: graph entity to update
  * @enable: enable/disable streaming status
  *
- * Walk the xvip graph entities list and find if subdev is present. Returns
- * streaming status of subdev and update the status as requested
+ * Update the streaming status of given entity.
  *
- * Return: streaming status (true or false) if successful or warn_on if subdev
- * is not present and return false
+ * Return: previous streaming status (true or false)
  */
-bool xvip_subdev_set_streaming(struct xvip_composite_device *xdev,
-			       struct v4l2_subdev *subdev, bool enable)
+static bool xvip_graph_entity_set_streaming(struct xvip_composite_device *xdev,
+					    struct xvip_graph_entity *entity,
+					    bool enable)
 {
-	struct xvip_graph_entity *entity;
-
-	list_for_each_entry(entity, &xdev->entities, list)
-		if (of_fwnode_handle(entity->node) == subdev->fwnode) {
-			bool status = entity->streaming;
-
-			entity->streaming = enable;
-			return status;
-		}
+	bool status = entity->streaming;
 
-	WARN(1, "Should never get here\n");
-	return false;
+	entity->streaming = enable;
+	return status;
 }
 
-static int xvip_entity_start_stop(struct xvip_composite_device *xdev, struct media_entity *entity, bool start)
+static int xvip_entity_start_stop(struct xvip_composite_device *xdev, struct xvip_graph_entity *entity, bool on)
 {
 	struct v4l2_subdev *subdev;
 	bool is_streaming;
 	int ret = 0;
 
 	dev_dbg(xdev->dev, "%s entity %s\n",
-		start ? "Starting" : "Stopping", entity->name);
-	subdev = media_entity_to_v4l2_subdev(entity);
+		on ? "Starting" : "Stopping", entity->entity->name);
+	subdev = media_entity_to_v4l2_subdev(entity->entity);
 
 	/* This is to maintain list of stream on/off devices */
-	is_streaming = xvip_subdev_set_streaming(xdev, subdev, start);
+	is_streaming = xvip_graph_entity_set_streaming(xdev, entity, on);
 
 	/*
 	 * start or stop the subdev only once in case if they are
 	 * shared between sub-graphs
 	 */
-	if (start && !is_streaming) {
+	if (on && !is_streaming) {
 		/* power-on subdevice */
 		ret = v4l2_subdev_call(subdev, core, s_power, 1);
 		if (ret < 0 && ret != -ENOIOCTLCMD) {
 			dev_err(xdev->dev,
 				"s_power on failed on subdev\n");
-			xvip_subdev_set_streaming(xdev, subdev, 0);
+			xvip_graph_entity_set_streaming(xdev, entity, 0);
 			return ret;
 		}
 
@@ -272,7 +287,7 @@ static int xvip_entity_start_stop(struct xvip_composite_device *xdev, struct med
 			if (ret < 0) {
 				dev_err(xdev->dev,
 					"s_frame_interval on failed on subdev\n");
-				xvip_subdev_set_streaming(xdev, subdev, 0);
+				xvip_graph_entity_set_streaming(xdev, entity, 0);
 				return ret;
 			}
 			dev_dbg(xdev->dev, "Changing frame interval of subdev: (%s) succesfully\n", subdev->name);
@@ -284,15 +299,15 @@ static int xvip_entity_start_stop(struct xvip_composite_device *xdev, struct med
 			dev_err(xdev->dev,
 				"s_stream on failed on subdev\n");
 			v4l2_subdev_call(subdev, core, s_power, 0);
-			xvip_subdev_set_streaming(xdev, subdev, 0);
+			xvip_graph_entity_set_streaming(xdev, entity, 0);
 		}
-	} else if (!start && is_streaming) {
+	} else if (!on && is_streaming) {
 		/* stream-off subdevice */
 		ret = v4l2_subdev_call(subdev, video, s_stream, 0);
 		if (ret < 0 && ret != -ENOIOCTLCMD) {
 			dev_err(xdev->dev,
 				"s_stream off failed on subdev\n");
-			xvip_subdev_set_streaming(xdev, subdev, 1);
+			xvip_graph_entity_set_streaming(xdev, entity, 1);
 		}
 
 		/* power-off subdevice */
@@ -308,13 +323,15 @@ static int xvip_entity_start_stop(struct xvip_composite_device *xdev, struct med
 static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
 {
 	struct xvip_graph_entity *entity;
+	struct v4l2_async_subdev *asd;
 	LIST_HEAD(ent_list);
 	int ret;
 
 	dev_dbg(g_xdev->dev, "notify complete, all subdevs registered\n");
 
 	/* Create links for every entity. */
-	list_for_each_entry(entity, &g_xdev->entities, list) {
+	list_for_each_entry(asd, &g_xdev->notifier.asd_list, asd_list) {
+		entity = to_xvip_entity(asd);
 		ret = xvip_graph_build_one(g_xdev, entity);
 		if (ret < 0)
 			return ret;
@@ -331,20 +348,22 @@ static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
 
 static int xvip_graph_notify_bound(struct v4l2_async_notifier *notifier,
 				   struct v4l2_subdev *subdev,
-				   struct v4l2_async_subdev *asd)
+				   struct v4l2_async_subdev *unused)
 {
 	struct xvip_graph_entity *entity;
+	struct v4l2_async_subdev *asd;
 
 	/* Locate the entity corresponding to the bound subdev and store the
 	 * subdev pointer.
 	 */
-	list_for_each_entry(entity, &g_xdev->entities, list) {
-		if (of_fwnode_handle(entity->node) != subdev->fwnode)
+	list_for_each_entry(asd, &g_xdev->notifier.asd_list, asd_list) {
+		entity = to_xvip_entity(asd);
+		if (entity->asd.match.fwnode != subdev->fwnode)
 			continue;
 
 		if (entity->subdev) {
-			dev_err(g_xdev->dev, "duplicate subdev for node %pOF\n",
-				entity->node);
+			dev_err(g_xdev->dev, "duplicate subdev for node %p\n",
+				entity->asd.match.fwnode);
 			return -EINVAL;
 		}
 
@@ -364,56 +383,60 @@ static const struct v4l2_async_notifier_operations xvip_graph_notify_ops = {
 };
 
 static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
-				struct device_node *node)
+				struct fwnode_handle *fwnode)
 {
-	struct xvip_graph_entity *entity;
-	struct device_node *remote;
-	struct device_node *ep = NULL;
+	struct fwnode_handle *remote;
+	struct fwnode_handle *ep = NULL;
 	int ret = 0;
 
 	//dev_dbg(xdev->dev, "parsing node %pOF\n", node);
 
 	while (1) {
-		ep = of_graph_get_next_endpoint(node, ep);
+		struct v4l2_async_subdev *asd;
+		
+		ep = fwnode_graph_get_next_endpoint(fwnode, ep);
 		if (ep == NULL)
 			break;
 
 		//dev_dbg(xdev->dev, "handling endpoint %pOF\n", ep);
 
-		remote = of_graph_get_remote_port_parent(ep);
+		remote = fwnode_graph_get_remote_port_parent(ep);
 		if (remote == NULL) {
 			ret = -EINVAL;
-			break;
+			goto err_notifier_cleanup;
 		}
+		
+		fwnode_handle_put(ep);
 
 		/* Skip entities that we have already processed. */
-		if (remote == xdev->dev->of_node ||
+		if (remote == of_fwnode_handle(xdev->dev->of_node) ||
 		    xvip_graph_find_entity(xdev, remote)) {
-			of_node_put(remote);
+			fwnode_handle_put(remote);
 			continue;
 		}
 
-		entity = devm_kzalloc(xdev->dev, sizeof(*entity), GFP_KERNEL);
-		if (entity == NULL) {
-			of_node_put(remote);
-			ret = -ENOMEM;
-			break;
+		asd = v4l2_async_notifier_add_fwnode_subdev(
+			&xdev->notifier, remote,
+			sizeof(struct xvip_graph_entity));
+		fwnode_handle_put(remote);
+		if (IS_ERR(asd)) {
+			ret = PTR_ERR(asd);
+			goto err_notifier_cleanup;
 		}
-
-		entity->node = remote;
-		entity->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
-		entity->asd.match.fwnode = of_fwnode_handle(remote);
-		list_add_tail(&entity->list, &xdev->entities);
-		xdev->num_subdevs++;
 	}
 
-	of_node_put(ep);
+	return 0;
+
+err_notifier_cleanup:
+	v4l2_async_notifier_cleanup(&xdev->notifier);
+	fwnode_handle_put(ep);
 	return ret;
 }
 
 static int xvip_graph_parse(struct xvip_composite_device *xdev)
 {
 	struct xvip_graph_entity *entity;
+	struct v4l2_async_subdev *asd;
 	int ret;
 
 	/*
@@ -422,14 +445,17 @@ static int xvip_graph_parse(struct xvip_composite_device *xdev)
 	 * loop will handle entities added at the end of the list while walking
 	 * the links.
 	 */
-	ret = xvip_graph_parse_one(xdev, xdev->dev->of_node);
+	ret = xvip_graph_parse_one(xdev, of_fwnode_handle(xdev->dev->of_node));
 	if (ret < 0)
 		return 0;
 
-	list_for_each_entry(entity, &xdev->entities, list) {
-		ret = xvip_graph_parse_one(xdev, entity->node);
-		if (ret < 0)
+	list_for_each_entry(asd, &xdev->notifier.asd_list, asd_list) {
+		entity = to_xvip_entity(asd);
+		ret = xvip_graph_parse_one(xdev, entity->asd.match.fwnode);
+		if (ret < 0) {
+			v4l2_async_notifier_cleanup(&xdev->notifier);
 			break;
+		}
 	}
 
 	return ret;
@@ -437,23 +463,12 @@ static int xvip_graph_parse(struct xvip_composite_device *xdev)
 
 static void xvip_graph_cleanup(struct xvip_composite_device *xdev)
 {
-	struct xvip_graph_entity *entityp;
-	struct xvip_graph_entity *entity;
-
 	v4l2_async_notifier_unregister(&xdev->notifier);
-
-	list_for_each_entry_safe(entity, entityp, &xdev->entities, list) {
-		of_node_put(entity->node);
-		list_del(&entity->list);
-	}
+	v4l2_async_notifier_cleanup(&xdev->notifier);
 }
 
 static int xvip_graph_init(struct xvip_composite_device *xdev)
 {
-	struct xvip_graph_entity *entity;
-	struct v4l2_async_subdev **subdevs = NULL;
-	unsigned int num_subdevs;
-	unsigned int i;
 	int ret;
 
 	/* Parse the graph to extract a list of subdevice DT nodes. */
@@ -463,26 +478,12 @@ static int xvip_graph_init(struct xvip_composite_device *xdev)
 		goto done;
 	}
 
-	if (!xdev->num_subdevs) {
+	if (list_empty(&xdev->notifier.asd_list)) {
 		dev_err(xdev->dev, "no subdev found in graph\n");
 		goto done;
 	}
 
 	/* Register the subdevices notifier. */
-	num_subdevs = xdev->num_subdevs;
-	subdevs = devm_kcalloc(xdev->dev, num_subdevs, sizeof(*subdevs),
-			       GFP_KERNEL);
-	if (subdevs == NULL) {
-		ret = -ENOMEM;
-		goto done;
-	}
-
-	i = 0;
-	list_for_each_entry(entity, &xdev->entities, list)
-		subdevs[i++] = &entity->asd;
-
-	xdev->notifier.subdevs = subdevs;
-	xdev->notifier.num_subdevs = num_subdevs;
 	xdev->notifier.ops = &xvip_graph_notify_ops;
 
 	ret = v4l2_async_notifier_register(&xdev->v4l2_dev, &xdev->notifier);
@@ -516,7 +517,7 @@ static int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)
 	int ret;
 
 	xdev->media_dev.dev = xdev->dev;
-	strlcpy(xdev->media_dev.model, "Xilinx Video Composite Device",
+	strscpy(xdev->media_dev.model, "Xilinx Video Composite Device",
 		sizeof(xdev->media_dev.model));
 	xdev->media_dev.hw_revision = 0;
 
@@ -536,11 +537,13 @@ static int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)
 
 static void xvip_start_stream(void)
 {
-	struct xvip_graph_entity *temp, *_temp;
+	struct xvip_graph_entity *entity;
+	struct v4l2_async_subdev *asd;
 	dev_dbg(g_xdev->dev, "Starting the stream \n");
-	list_for_each_entry_safe(temp, _temp, &g_xdev->entities, list)
-			xvip_entity_start_stop(g_xdev, temp->entity, true);
-
+	list_for_each_entry(asd, &g_xdev->notifier.asd_list, asd_list) {
+		entity = to_xvip_entity(asd);
+		xvip_entity_start_stop(g_xdev, entity, true);
+	}
 	g_xdev->is_streaming = true;
 }
 
@@ -586,7 +589,7 @@ static int media_ctl_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	g_xdev->dev = &pdev->dev;
-	INIT_LIST_HEAD(&g_xdev->entities);
+	v4l2_async_notifier_init(&g_xdev->notifier);
 
 	ret = xvip_composite_v4l2_init(g_xdev);
 	if (ret < 0)
-- 
2.17.1

