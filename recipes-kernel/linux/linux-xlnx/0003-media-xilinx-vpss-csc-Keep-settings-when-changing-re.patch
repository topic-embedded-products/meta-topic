From 1a6bb2409521c1a9d40e82099437bddfbb62f8f4 Mon Sep 17 00:00:00 2001
From: Mike Looijmans <mike.looijmans@topic.nl>
Date: Fri, 16 Apr 2021 09:19:38 +0200
Subject: [PATCH 3/3] media/xilinx-vpss-csc: Keep settings when changing
 resolution

The CSC driver resets the conversion matrix when the resolution or color
model changes, but only does this halfway so that changing any setting
will bring back the old values and thus cause the reported and actual
settings to mismatch.

Since it's rather unexpected to just reset the controls on any change, the
simplest fix is to not reset the controls when the resolution or color
model changes and keep the controls (and matrix) as they were.

This fixes that the controls get out of sync and also that the controls
are unexpectedly being reset.

Signed-off-by: Mike Looijmans <mike.looijmans@topic.nl>
---
 .../media/platform/xilinx/xilinx-vpss-csc.c   | 93 ++++++++-----------
 1 file changed, 41 insertions(+), 52 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-vpss-csc.c b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
index 51c7440bf617..2975a6a303bc 100644
--- a/drivers/media/platform/xilinx/xilinx-vpss-csc.c
+++ b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
@@ -310,16 +310,6 @@ static void xcsc_write_coeff(struct xcsc_dev *xcsc)
 	xcsc_write_rgb_offset(xcsc);
 }
 
-static void xcsc_set_v4l2_ctrl_defaults(struct xcsc_dev *xcsc)
-{
-	unsigned int i;
-
-	mutex_lock(xcsc->ctrl_handler.lock);
-	for (i = 0; i < XCSC_COLOR_CTRL_COUNT; i++)
-		xcsc->custom_ctrls[i]->cur.val = XCSC_COLOR_CTRL_DEFAULT;
-	mutex_unlock(xcsc->ctrl_handler.lock);
-}
-
 static void xcsc_set_control_defaults(struct xcsc_dev *xcsc)
 {
 	/* These are VPSS CSC IP specific defaults */
@@ -448,6 +438,45 @@ xcsc_rgb_to_ycrcb(struct xcsc_dev *xcsc, s32 *clip_max,
 	*clip_max = BIT(xcsc->color_depth) - 1;
 }
 
+static void
+xcsc_correct_coeff(struct xcsc_dev *xcsc,
+		   s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	s32 csc_change[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	s32 csc_extra[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	u32 mbus_in = xcsc->formats[XVIP_PAD_SINK].code;
+	u32 mbus_out = xcsc->formats[XVIP_PAD_SOURCE].code;
+
+#ifdef DEBUG
+	xcsc_log_coeff(xcsc->xvip.dev, temp);
+#endif
+	if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 && mbus_out == mbus_in) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to RGB", __func__);
+		xcsc_copy_coeff(xcsc->k_hw,
+				(const s32 (*)[XV_CSC_K_MAX_COLUMNS + 1])temp);
+	} else if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to YUV", __func__);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(temp, csc_change, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out == MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to RGB", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to YUV", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, csc_extra);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_extra, csc_change, xcsc->k_hw);
+	} else {
+		/* Should never get here */
+		WARN_ON(1);
+	}
+}
+
 static int xcsc_update_formats(struct xcsc_dev *xcsc)
 {
 	u32 color_in, color_out;
@@ -521,6 +550,7 @@ static int xcsc_update_formats(struct xcsc_dev *xcsc)
 	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
 	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
 
+	xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
 	xcsc_write_coeff(xcsc);
 
 	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
@@ -560,45 +590,6 @@ __xcsc_get_pad_format(struct xcsc_dev *xcsc,
 	return format;
 }
 
-static void
-xcsc_correct_coeff(struct xcsc_dev *xcsc,
-		   s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
-{
-	s32 csc_change[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
-	s32 csc_extra[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
-	u32 mbus_in = xcsc->formats[XVIP_PAD_SINK].code;
-	u32 mbus_out = xcsc->formats[XVIP_PAD_SOURCE].code;
-
-#ifdef DEBUG
-	xcsc_log_coeff(xcsc->xvip.dev, temp);
-#endif
-	if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 && mbus_out == mbus_in) {
-		dev_dbg(xcsc->xvip.dev, "%s : RGB to RGB", __func__);
-		xcsc_copy_coeff(xcsc->k_hw,
-				(const s32 (*)[XV_CSC_K_MAX_COLUMNS + 1])temp);
-	} else if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 &&
-		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
-		dev_dbg(xcsc->xvip.dev, "%s : RGB to YUV", __func__);
-		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
-		xcsc_matrix_multiply(temp, csc_change, xcsc->k_hw);
-	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
-		   mbus_out == MEDIA_BUS_FMT_RBG888_1X24) {
-		dev_dbg(xcsc->xvip.dev, "%s : YUV to RGB", __func__);
-		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
-		xcsc_matrix_multiply(csc_change, temp, xcsc->k_hw);
-	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
-		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
-		dev_dbg(xcsc->xvip.dev, "%s : YUV to YUV", __func__);
-		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
-		xcsc_matrix_multiply(csc_change, temp, csc_extra);
-		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
-		xcsc_matrix_multiply(csc_extra, csc_change, xcsc->k_hw);
-	} else {
-		/* Should never get here */
-		WARN_ON(1);
-	}
-}
-
 static void xcsc_set_brightness(struct xcsc_dev *xcsc)
 {
 	unsigned int i, j;
@@ -825,9 +816,7 @@ static int xcsc_set_format(struct v4l2_subdev *subdev,
 
 	fmt->format = *__format;
 	xcsc_update_formats(xcsc);
-	xcsc_set_control_defaults(xcsc);
-	xcsc_set_v4l2_ctrl_defaults(xcsc);
-	dev_info(xcsc->xvip.dev, "VPSS CSC color controls reset to defaults");
+
 	return 0;
 }
 
-- 
2.17.1

