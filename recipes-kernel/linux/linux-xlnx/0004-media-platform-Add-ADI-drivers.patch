From 7b6f1b6fb74fca2214d745dbfad68377af7be813 Mon Sep 17 00:00:00 2001
From: Mike Looijmans <mike.looijmans@topic.nl>
Date: Mon, 17 Feb 2020 10:56:38 +0100
Subject: [PATCH 4/8] media/platform: Add ADI drivers

Add drivers from ADIs xcomm_zynq branch, in particular this adds the
axi-hdmi-rx driver for the HDMI-IN on the florida boards. Added the
other drivers to facilitate future merges.
---
 drivers/media/platform/Kconfig          |  27 +
 drivers/media/platform/Makefile         |   3 +
 drivers/media/platform/adi-axi-fb.c     | 314 ++++++++
 drivers/media/platform/axi-hdmi-rx.c    | 977 ++++++++++++++++++++++++
 drivers/media/platform/imageon-bridge.c | 301 ++++++++
 5 files changed, 1622 insertions(+)
 create mode 100644 drivers/media/platform/adi-axi-fb.c
 create mode 100644 drivers/media/platform/axi-hdmi-rx.c
 create mode 100644 drivers/media/platform/imageon-bridge.c

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 54fe90acb5b2..e7ccb8b34004 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -122,6 +122,26 @@ config VIDEO_STM32_DCMI
 	  To compile this driver as a module, choose M here: the module
 	  will be called stm32-dcmi.
 
+config VIDEO_AXI_HDMI_RX
+	tristate "AXI-HDMI-RX support"
+	depends on MEDIA_SUPPORT && VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API
+	select I2C_ALGOBIT
+	select VIDEO_ADV7604
+	select VIDEOBUF2_DMA_CONTIG
+	---help---
+	  To compile this driver as a module, choose M here: the
+	  module will be called axi-hdmi-rx.
+
+config VIDEO_IMAGEON_BRIDGE
+	tristate "IMAGEON-BRIDGE support"
+	depends on MEDIA_SUPPORT && VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API
+	select I2C_ALGOBIT
+	select VIDEO_ADV7511
+	select VIDEO_ADV7604
+	---help---
+	  To compile this driver as a module, choose M here: the
+	  module will be called imageon-bridge.
+
 config VIDEO_RENESAS_CEU
 	tristate "Renesas Capture Engine Unit (CEU) driver"
 	depends on VIDEO_DEV && VIDEO_V4L2
@@ -495,6 +515,13 @@ config VIDEO_TI_SC
 config VIDEO_TI_CSC
 	tristate
 
+config ADI_AXI_VIDEO_FRAME_BUFFER
+	tristate "ADI AXI frame buffer"
+	depends on MEDIA_SUPPORT
+	---help---
+	  To compile this driver as a module, choose M here: the
+	  module will be called adi-axi-fb.
+
 menuconfig V4L_TEST_DRIVERS
 	bool "Media test drivers"
 	depends on MEDIA_CAMERA_SUPPORT
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 41322ab65802..4663df3e88dc 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -56,6 +56,9 @@ obj-y					+= stm32/
 obj-y					+= davinci/
 
 obj-$(CONFIG_VIDEO_SH_VOU)		+= sh_vou.o
+obj-$(CONFIG_VIDEO_AXI_HDMI_RX)		+= axi-hdmi-rx.o
+obj-$(CONFIG_VIDEO_IMAGEON_BRIDGE)	+= imageon-bridge.o
+obj-$(CONFIG_ADI_AXI_VIDEO_FRAME_BUFFER)	+= adi-axi-fb.o
 
 obj-$(CONFIG_SOC_CAMERA)		+= soc_camera/
 
diff --git a/drivers/media/platform/adi-axi-fb.c b/drivers/media/platform/adi-axi-fb.c
new file mode 100644
index 000000000000..07e03e1d84fa
--- /dev/null
+++ b/drivers/media/platform/adi-axi-fb.c
@@ -0,0 +1,314 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019 Analog Devices Inc.
+ * ADI Frame Buffer Driver
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <media/media-device.h>
+#include <linux/fpga/adi-axi-common.h>
+
+/* DMA defines */
+#define DMAC_REG_CTRL				0x400
+#define DMAC_REG_START_TRANSFER			0x408
+#define DMAC_REG_FLAGS				0x40c
+#define DMAC_REG_DEST_ADDRESS			0x410
+#define DMAC_REG_SRC_ADDRESS			0x414
+#define DMAC_REG_X_LENGTH			0x418
+#define DMAC_REG_Y_LENGTH			0x41c
+#define DMAC_REG_DEST_STRIDE			0x420
+#define DMAC_REG_SRC_STRIDE			0x424
+#define DMAC_REG_FRAME_LOCK_CONFIG		0x454
+#define DMAC_REG_FRAME_LOCK_STRIDE		0x458
+
+#define DMAC_CTRL_ENABLE			BIT(0)
+#define DMAC_TRANSFER_SUBMIT			BIT(0)
+#define DMAC_FLOCK_WAIT_WRITER			BIT(9)
+
+#define DMAC_FLAGS_CYCLIC			BIT(0)
+#define DMAC_FLAGS_TLAST			BIT(1)
+#define DMAC_FLAGS_FLOCK			BIT(3)
+
+#define DMAC_DEFAULT_FLAGS (DMAC_FLAGS_FLOCK | DMAC_FLAGS_CYCLIC | \
+			    DMAC_FLAGS_TLAST)
+
+struct hdl_subdev {
+	void __iomem *tx_dma_regs;
+	void __iomem *rx_dma_regs;
+};
+
+struct frame_buffer {
+	struct media_device media_dev;
+
+	struct resource video_ram_buf;
+	struct hdl_subdev hdl_subdev;
+	u32 num_frames;
+	u32 mode;
+	u32 distance;
+	u32 line_stride;
+	u32 frame_stride;
+	/* resolution[0] width, resolution[1] height */
+	u32 resolution[2];
+	u32 dwidth;
+};
+
+enum {
+	TX_DMA,
+	RX_DMA
+};
+
+static u32 adi_fb_reg_read(void __iomem *base_addr, u32 addr)
+{
+	return ioread32(base_addr + addr);
+}
+
+static void adi_fb_reg_write(void __iomem *base_addr, u32 addr, u32 value)
+{
+	iowrite32(value, base_addr + addr);
+}
+
+static void adi_fb_reg_clr(void __iomem *base_addr, u32 addr, u32 clr)
+{
+	adi_fb_reg_write(base_addr, addr,
+			 adi_fb_reg_read(base_addr, addr) & ~clr);
+}
+
+static void adi_fb_reg_set(void __iomem *base_addr, u32 addr, u32 set)
+{
+	adi_fb_reg_write(base_addr, addr,
+			 adi_fb_reg_read(base_addr, addr) | set);
+}
+
+static void adi_fb_init(struct frame_buffer *buff, int dma_dir)
+{
+	void __iomem *base_addr;
+	u32 stride, dir, flock_cfg;
+
+	if (dma_dir == RX_DMA) {
+		base_addr = buff->hdl_subdev.rx_dma_regs;
+		dir = DMAC_REG_DEST_ADDRESS;
+		stride = DMAC_REG_DEST_STRIDE;
+		flock_cfg = ((buff->distance) << 16) | ((buff->mode) << 8) |
+			    (buff->num_frames);
+	} else {
+		base_addr = buff->hdl_subdev.tx_dma_regs;
+		dir = DMAC_REG_SRC_ADDRESS;
+		stride = DMAC_REG_SRC_STRIDE;
+		flock_cfg = ((buff->distance) << 16) | ((buff->mode) << 8) |
+			    DMAC_FLOCK_WAIT_WRITER | (buff->num_frames);
+	}
+
+	/* reset DMAC */
+	adi_fb_reg_clr(base_addr, DMAC_REG_CTRL, DMAC_CTRL_ENABLE);
+
+	/* Init DMAC */
+	adi_fb_reg_set(base_addr, DMAC_REG_CTRL, DMAC_CTRL_ENABLE);
+	adi_fb_reg_write(base_addr, DMAC_REG_FLAGS, DMAC_DEFAULT_FLAGS);
+
+	adi_fb_reg_write(base_addr, dir, buff->video_ram_buf.start);
+	/* h size */
+	adi_fb_reg_write(base_addr, DMAC_REG_X_LENGTH,
+			 ((buff->resolution[0] * buff->dwidth) - 1));
+	/* h offset */
+	adi_fb_reg_write(base_addr, stride, buff->line_stride);
+	/* v size */
+	adi_fb_reg_write(base_addr, DMAC_REG_Y_LENGTH,
+			 (buff->resolution[1] - 1));
+
+	adi_fb_reg_write(base_addr, DMAC_REG_FRAME_LOCK_CONFIG, flock_cfg);
+	/* total active */
+	adi_fb_reg_write(base_addr, DMAC_REG_FRAME_LOCK_STRIDE,
+			buff->frame_stride);
+	/* submit transfer */
+	adi_fb_reg_set(base_addr, DMAC_REG_START_TRANSFER,
+		       DMAC_TRANSFER_SUBMIT);
+}
+
+static void frame_buffer_media_unregister(void *data)
+{
+	struct frame_buffer *frm_buff = data;
+
+	media_device_unregister(&frm_buff->media_dev);
+}
+
+static int frame_buffer_probe(struct platform_device *pdev)
+{
+	struct frame_buffer *frm_buff;
+	struct device_node *np;
+	struct resource *res;
+	int ret;
+	u32 tmp;
+
+	frm_buff = devm_kzalloc(&pdev->dev, sizeof(struct frame_buffer),
+				GFP_KERNEL);
+	if (!frm_buff)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, frm_buff);
+
+	/* Get reserved memory region from Device-tree */
+	np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+	if (!np) {
+		/* Get physical address of FB from reg property */
+		res = platform_get_resource_byname(pdev,
+						IORESOURCE_MEM, "fb_mem");
+		if (!res) {
+			dev_err(&pdev->dev, "No frame buffer memory.\n");
+			return -EFAULT;
+		}
+		frm_buff->video_ram_buf = *res;
+	} else {
+		ret = of_address_to_resource(np, 0, &frm_buff->video_ram_buf);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"No memory address assigned to the region\n");
+			return ret;
+		}
+	}
+	dev_info(&pdev->dev, "Allocated reserved memory, paddr: 0x%0X\n",
+		 (unsigned int)frm_buff->video_ram_buf.start);
+
+	/* Get physical address of DMAs*/
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tx_dma");
+	frm_buff->hdl_subdev.tx_dma_regs =
+		devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(frm_buff->hdl_subdev.tx_dma_regs))
+		return PTR_ERR(frm_buff->hdl_subdev.tx_dma_regs);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rx_dma");
+	frm_buff->hdl_subdev.rx_dma_regs =
+		devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(frm_buff->hdl_subdev.rx_dma_regs))
+		return PTR_ERR(frm_buff->hdl_subdev.rx_dma_regs);
+
+	/* Get frames number */
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-frm-buf-nr",
+					&tmp);
+	if (ret) {
+		frm_buff->num_frames = 3;
+		dev_info(&pdev->dev, "No frames number specified. Using %d\n",
+			 frm_buff->num_frames);
+	} else {
+		frm_buff->num_frames = tmp;
+	}
+
+	/* Get frame distance */
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-distance", &tmp);
+	if (ret) {
+		frm_buff->distance = 0;
+		dev_info(&pdev->dev, "No distance specified. Using %d\n",
+			 frm_buff->distance);
+	} else {
+		frm_buff->distance = tmp;
+	}
+
+	/* Get operating mode */
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-mode", &tmp);
+	if (ret) {
+		frm_buff->mode = 0;
+		dev_info(&pdev->dev,
+			 "No operating mode specified. Using framelock\n");
+	} else {
+		frm_buff->mode = tmp;
+	}
+
+	/* Get data width */
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-dwidth", &tmp);
+	if (ret) {
+		frm_buff->dwidth = 4;
+		dev_info(&pdev->dev, "No data width specified. Using %d byte\n",
+			 frm_buff->dwidth);
+	} else {
+		frm_buff->dwidth = tmp;
+	}
+
+	/* Get resolution mode */
+	ret = device_property_read_u32_array(&pdev->dev, "adi,flock-resolution",
+					     frm_buff->resolution, 2);
+	if (ret) {
+		frm_buff->resolution[0] = 1920;
+		frm_buff->resolution[1] = 1080;
+		dev_info(&pdev->dev,
+			 "No resolution specified. Using default %d x %d\n",
+			 frm_buff->resolution[0], frm_buff->resolution[1]);
+	}
+
+	/* Get optional line stride*/
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-line-stride",
+					&tmp);
+	frm_buff->line_stride = frm_buff->resolution[0] * frm_buff->dwidth;
+	if (ret) {
+		dev_info(&pdev->dev, "No line stride specified. Using %d bytes\n",
+			 frm_buff->line_stride);
+	} else {
+		if (tmp > frm_buff->line_stride)
+			frm_buff->line_stride = tmp;
+	}
+
+	/* Get optional frame stride*/
+	ret = device_property_read_u32(&pdev->dev, "adi,flock-frm-stride",
+					&tmp);
+	frm_buff->frame_stride =
+		(frm_buff->line_stride * frm_buff->resolution[1]);
+	if (ret) {
+		dev_info(&pdev->dev, "No frame stride specified. Using %d bytes\n",
+			 frm_buff->frame_stride);
+	} else {
+		if (tmp > frm_buff->frame_stride)
+			frm_buff->frame_stride = tmp;
+	}
+
+	if ((frm_buff->video_ram_buf.end - frm_buff->video_ram_buf.start) <
+			frm_buff->frame_stride * frm_buff->num_frames) {
+		dev_err(&pdev->dev, "FB does not fit in reserved memory\n");
+		return -ENOMEM;
+	}
+
+	adi_fb_init(frm_buff, TX_DMA);
+	adi_fb_init(frm_buff, RX_DMA);
+
+	frm_buff->media_dev.dev = &pdev->dev;
+
+	strlcpy(frm_buff->media_dev.model, "ADI AXI Frame Buffer",
+		sizeof(frm_buff->media_dev.model));
+
+	frm_buff->media_dev.hw_revision = 0;
+
+	media_device_init(&frm_buff->media_dev);
+
+	ret = media_device_register(&frm_buff->media_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register media_device\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(&pdev->dev,
+		frame_buffer_media_unregister, frm_buff);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct of_device_id frame_buffer_of_match[] = {
+	{ .compatible = "adi,axi-framebuffer-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, frame_buffer_of_match);
+
+static struct platform_driver frame_buffer_driver = {
+	.driver			= {
+		.name		= "axi-framebuffer",
+		.of_match_table = frame_buffer_of_match,
+	},
+	.probe			= frame_buffer_probe,
+};
+module_platform_driver(frame_buffer_driver);
+
+MODULE_AUTHOR("Bogdan Togoean <bogdan.togorean@analog.com>");
+MODULE_DESCRIPTION("Analog Devices AXI Frame Buffer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/axi-hdmi-rx.c b/drivers/media/platform/axi-hdmi-rx.c
new file mode 100644
index 000000000000..51a9abdb0bf6
--- /dev/null
+++ b/drivers/media/platform/axi-hdmi-rx.c
@@ -0,0 +1,977 @@
+/*
+ * Driver for the AXI-HDMI-RX core
+ *
+ * Copyright 2012-2013 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/dmaengine.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/of_graph.h>
+
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/i2c/adv7604.h>
+
+#include <linux/fpga/adi-axi-common.h>
+
+#define AXI_HDMI_RX_REG_ENABLE		0x040
+#define AXI_HDMI_RX_REG_CONFIG		0x044
+#define AXI_HDMI_RX_REG_CLK_COUNT	0x054
+#define AXI_HDMI_RX_REG_CLK_RATIO	0x058
+#define AXI_HDMI_RX_REG_DMA_STATUS	0x060
+#define AXI_HDMI_RX_REG_TPM_STATUS	0x064
+#define AXI_HDMI_RX_REG_STATUS		0x080
+#define AXI_HDMI_RX_REG_TIMING		0x400
+#define AXI_HDMI_RX_REG_DETECTED_TIMING 0x404
+
+#define AXI_HDMI_RX_CONFIG_EDGE_SEL	BIT(3)
+#define AXI_HDMI_RX_CONFIG_BGR		BIT(2)
+#define AXI_HDMI_RX_CONFIG_PACKED	BIT(1)
+#define AXI_HDMI_RX_CONFIG_CSC_BYPASS	BIT(0)
+
+struct axi_hdmi_rx_stream {
+	struct video_device vdev;
+	struct vb2_queue q;
+	struct v4l2_subdev *subdev;
+	struct mutex lock;
+	spinlock_t spinlock;
+	u32 width, height;
+	u32 stride;
+
+	__u32 pixelformat;
+
+	struct dma_chan *chan;
+	struct list_head queued_buffers;
+};
+
+struct axi_hdmi_rx {
+	struct v4l2_device v4l2_dev;
+
+	struct axi_hdmi_rx_stream stream;
+
+	int hotplug_gpio;
+
+	void __iomem *base;
+
+	struct v4l2_async_notifier notifier;
+	struct v4l2_async_subdev asd;
+	struct v4l2_async_subdev *asds[1];
+
+	u8 bus_width;
+
+	u8 edid_data[256];
+	u8 edid_blocks;
+};
+
+struct axi_hdmi_rx_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct list_head head;
+};
+
+static void axi_hdmi_rx_write(struct axi_hdmi_rx *axi_hdmi_rx,
+	unsigned int reg, unsigned int val)
+{
+	writel(val, axi_hdmi_rx->base + reg);
+}
+
+static unsigned int axi_hdmi_rx_read(struct axi_hdmi_rx *axi_hdmi_rx,
+	unsigned int reg)
+{
+	return readl(axi_hdmi_rx->base + reg);
+}
+
+static struct axi_hdmi_rx *to_axi_hdmi_rx(struct v4l2_device *v4l2_dev)
+{
+	return container_of(v4l2_dev, struct axi_hdmi_rx, v4l2_dev);
+}
+
+static struct axi_hdmi_rx_stream *axi_hdmi_rx_file_to_stream(struct file *file)
+{
+	struct axi_hdmi_rx *axi_hdmi_rx = video_drvdata(file);
+	return &axi_hdmi_rx->stream;
+}
+
+static struct axi_hdmi_rx_buffer *vb2_buf_to_hdmi_rx_buf(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *v4l2_buf = to_vb2_v4l2_buffer(vb);
+	return container_of(v4l2_buf, struct axi_hdmi_rx_buffer, vb);
+}
+
+static const struct v4l2_file_operations axi_hdmi_rx_fops = {
+	.owner = THIS_MODULE,
+	.open = v4l2_fh_open,
+	.release = vb2_fop_release,
+	.unlocked_ioctl = video_ioctl2,
+	.read = vb2_fop_read,
+	.poll = vb2_fop_poll,
+	.mmap = vb2_fop_mmap,
+};
+
+static int axi_hdmi_rx_queue_setup(struct vb2_queue *q,
+	unsigned int *num_buffers, unsigned int *num_planes,
+	unsigned int sizes[], struct device *alloc_ctxs[])
+{
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(q);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	if (*num_buffers < 1)
+		*num_buffers = 1;
+
+	if (*num_planes) {
+		if (sizes[0] < s->stride * s->height)
+			return -EINVAL;
+	} else {
+		sizes[0] = s->stride * s->height;
+		*num_planes = 1;
+	}
+
+	return 0;
+}
+
+static int axi_hdmi_rx_buf_prepare(struct vb2_buffer *vb)
+{
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(vb->vb2_queue);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	unsigned size;
+
+	size = s->stride * s->height;
+	if (vb2_plane_size(vb, 0) < size) {
+		pr_info("data will not fit into plane (%lu < %u)\n",
+					vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+	return 0;
+}
+
+static void axi_hdmi_rx_dma_done(void *arg)
+{
+	struct axi_hdmi_rx_buffer *buf = arg;
+	struct vb2_queue *q = buf->vb.vb2_buf.vb2_queue;
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(q);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->spinlock, flags);
+	list_del(&buf->head);
+	spin_unlock_irqrestore(&s->spinlock, flags);
+
+	buf->vb.vb2_buf.timestamp = ktime_get_ns();
+	vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+}
+
+static void axi_hdmi_rx_buf_queue(struct vb2_buffer *vb)
+{
+	struct axi_hdmi_rx_buffer *buf = vb2_buf_to_hdmi_rx_buf(vb);
+	struct dma_async_tx_descriptor *desc;
+	struct vb2_queue *q = vb->vb2_queue;
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(q);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	unsigned int bpp;
+	struct dma_interleaved_template *xt;
+	unsigned long size;
+	unsigned long flags;
+	dma_addr_t addr;
+	dma_cookie_t cookie;
+
+	addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+	size = vb2_get_plane_payload(vb, 0);
+
+	xt = kzalloc(sizeof(struct dma_async_tx_descriptor) +
+				sizeof(struct data_chunk), GFP_KERNEL);
+	if (!xt) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	switch (s->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+		bpp = 3;
+		break;
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_VYUY:
+	case V4L2_PIX_FMT_UYVY:
+		bpp = 2;
+		break;
+	default:
+		bpp = 4;
+		break;
+	}
+
+	xt->dst_start = addr;
+	xt->src_inc = false;
+	xt->dst_inc = true;
+	xt->src_sgl = false;
+	xt->dst_sgl = true;
+	xt->frame_size = 1;
+	xt->numf = s->height;
+	xt->sgl[0].size = s->width * bpp;
+	xt->sgl[1].icg = s->stride - (s->width * bpp);
+	xt->dir = DMA_DEV_TO_MEM;
+
+	desc = dmaengine_prep_interleaved_dma(s->chan, xt, DMA_PREP_INTERRUPT);
+	kfree(xt);
+	if (!desc) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		return;
+	}
+	desc->callback = axi_hdmi_rx_dma_done;
+	desc->callback_param = buf;
+
+	cookie = dmaengine_submit(desc);
+	if (cookie < 0) {
+		vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	spin_lock_irqsave(&s->spinlock, flags);
+	list_add_tail(&buf->head, &s->queued_buffers);
+	spin_unlock_irqrestore(&s->spinlock, flags);
+
+	if (vb2_is_streaming(q))
+		dma_async_issue_pending(s->chan);
+}
+
+static int axi_hdmi_rx_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(q);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	dma_async_issue_pending(s->chan);
+	return 0;
+}
+
+static void axi_hdmi_rx_stop_streaming(struct vb2_queue *q)
+{
+	struct axi_hdmi_rx *hdmi_rx = vb2_get_drv_priv(q);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	struct axi_hdmi_rx_buffer *buf;
+	unsigned long flags;
+
+	dmaengine_terminate_all(s->chan);
+
+	spin_lock_irqsave(&s->spinlock, flags);
+
+	list_for_each_entry(buf, &s->queued_buffers, head)
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+
+	INIT_LIST_HEAD(&s->queued_buffers);
+
+	spin_unlock_irqrestore(&s->spinlock, flags);
+
+	vb2_wait_for_all_buffers(q);
+}
+
+static const struct vb2_ops axi_hdmi_rx_qops = {
+	.queue_setup = axi_hdmi_rx_queue_setup,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+
+	.buf_prepare = axi_hdmi_rx_buf_prepare,
+	.buf_queue = axi_hdmi_rx_buf_queue,
+	.start_streaming = axi_hdmi_rx_start_streaming,
+	.stop_streaming = axi_hdmi_rx_stop_streaming,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+
+static int axi_hdmi_rx_g_register(struct file *file, void *priv_fh,
+	struct v4l2_dbg_register *reg)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+
+	switch (reg->reg) {
+	case ADI_AXI_REG_VERSION:
+	case ADI_AXI_REG_ID:
+	case AXI_HDMI_RX_REG_ENABLE:
+	case AXI_HDMI_RX_REG_CONFIG:
+	case AXI_HDMI_RX_REG_CLK_COUNT:
+	case AXI_HDMI_RX_REG_CLK_RATIO:
+	case AXI_HDMI_RX_REG_DMA_STATUS:
+	case AXI_HDMI_RX_REG_TPM_STATUS:
+	case AXI_HDMI_RX_REG_STATUS:
+	case AXI_HDMI_RX_REG_TIMING:
+	case AXI_HDMI_RX_REG_DETECTED_TIMING:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	reg->val = axi_hdmi_rx_read(hdmi_rx, reg->reg);
+	reg->size = 4;
+
+	return 0;
+}
+
+static int axi_hdmi_rx_s_register(struct file *file, void *priv_fh,
+	const struct v4l2_dbg_register *reg)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+
+	switch (reg->reg) {
+	case AXI_HDMI_RX_REG_ENABLE:
+	case AXI_HDMI_RX_REG_CONFIG:
+	case AXI_HDMI_RX_REG_DMA_STATUS:
+	case AXI_HDMI_RX_REG_TPM_STATUS:
+	case AXI_HDMI_RX_REG_STATUS:
+	case AXI_HDMI_RX_REG_TIMING:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	axi_hdmi_rx_write(hdmi_rx, reg->reg, reg->val);
+
+	return 0;
+}
+#endif
+
+static int axi_hdmi_rx_log_status(struct file *file, void *priv)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+
+	v4l2_device_call_all(&hdmi_rx->v4l2_dev, 0, core, log_status);
+	return 0;
+}
+
+static int axi_hdmi_rx_querycap(struct file *file, void *priv_fh,
+	struct v4l2_capability *vcap)
+{
+	strlcpy(vcap->driver, "axi_hdmi_rx", sizeof(vcap->driver));
+	strlcpy(vcap->card, "axi_hdmi_rx", sizeof(vcap->card));
+	snprintf(vcap->bus_info, sizeof(vcap->bus_info), "platform:axi-hdmi-rx");
+	vcap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	vcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int axi_hdmi_rx_streamon(struct file *file, void *priv_fh,
+	enum v4l2_buf_type buffer_type)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = axi_hdmi_rx_file_to_stream(file);
+
+	if (buffer_type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	/* Clear status bits */
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_STATUS, 0xf);
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_ENABLE, 1);
+
+	return vb2_streamon(&s->q, buffer_type);
+}
+
+static int axi_hdmi_rx_streamoff(struct file *file, void *priv_fh,
+	enum v4l2_buf_type buffer_type)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = axi_hdmi_rx_file_to_stream(file);
+	int ret;
+
+	if (buffer_type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	ret = vb2_streamoff(&s->q, buffer_type);
+
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_ENABLE, 0);
+
+	return ret;
+}
+
+static int axi_hdmi_rx_s_dv_timings(struct file *file, void *priv_fh,
+	struct v4l2_dv_timings *timings)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	return v4l2_subdev_call(s->subdev, video, s_dv_timings, timings);
+}
+
+static int axi_hdmi_rx_g_dv_timings(struct file *file, void *priv_fh,
+	struct v4l2_dv_timings *timings)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	return v4l2_subdev_call(s->subdev, video, g_dv_timings, timings);
+}
+
+static int axi_hdmi_rx_enum_dv_timings(struct file *file, void *priv_fh,
+	struct v4l2_enum_dv_timings *timings)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	return v4l2_subdev_call(s->subdev, pad, enum_dv_timings, timings);
+}
+
+static int axi_hdmi_rx_query_dv_timings(struct file *file, void *priv_fh,
+	struct v4l2_dv_timings *timings)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	return v4l2_subdev_call(s->subdev, video, query_dv_timings,
+		timings);
+}
+
+static int axi_hdmi_rx_dv_timings_cap(struct file *file, void *priv_fh,
+	struct v4l2_dv_timings_cap *cap)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	return v4l2_subdev_call(s->subdev, pad, dv_timings_cap, cap);
+}
+
+static int axi_hdmi_rx_enum_fmt_vid_cap(struct file *file, void *priv_fh,
+	struct v4l2_fmtdesc *f)
+{
+	switch (f->index) {
+	case 0:
+		strlcpy(f->description, "BGR32", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_BGR32;
+		break;
+	case 1:
+		strlcpy(f->description, "RGB24", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_RGB24;
+		break;
+	case 2:
+		strlcpy(f->description, "RGB32", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_RGB32;
+		break;
+	case 3:
+		strlcpy(f->description, "BGR24", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_BGR24;
+		break;
+	case 4:
+		strlcpy(f->description, "YCBCr", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_YVYU;
+		break;
+	case 5:
+		strlcpy(f->description, "YCrCb", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case 6:
+		strlcpy(f->description, "CbCrY", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_VYUY;
+		break;
+	case 7:
+		strlcpy(f->description, "CrCbY", sizeof(f->description));
+		f->pixelformat = V4L2_PIX_FMT_UYVY;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int axi_hdmi_rx_g_fmt_vid_cap(struct file *file, void *priv_fh,
+	struct v4l2_format *f)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	pix->width = s->width;
+	pix->height = s->height;
+	pix->bytesperline = s->stride;
+	pix->field = V4L2_FIELD_NONE;
+
+	switch (s->pixelformat) {
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_BGR24:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_VYUY:
+	case V4L2_PIX_FMT_UYVY:
+		pix->colorspace = V4L2_COLORSPACE_REC709;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pix->pixelformat = s->pixelformat;
+	pix->sizeimage = pix->bytesperline * pix->height;
+
+	return 0;
+}
+
+static int axi_hdmi_rx_try_fmt_vid_cap(struct file *file, void *priv_fh,
+	struct v4l2_format *f)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int ret;
+
+	v4l_bound_align_image(&pix->width, 176, 1920, 0, &pix->height, 144,
+		1080, 0, 0);
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = ADV7611_PAD_SOURCE;
+	ret = v4l2_subdev_call(s->subdev, pad, get_fmt, NULL, &fmt);
+	if (ret)
+		return ret;
+
+	v4l2_fill_pix_format(pix, &fmt.format);
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_RGB32:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		pix->bytesperline = pix->width * 4;
+		break;
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_VYUY:
+	case V4L2_PIX_FMT_UYVY:
+		pix->colorspace = V4L2_COLORSPACE_REC709;;
+		pix->bytesperline = pix->width * 2;
+		break;
+	default:
+		pix->pixelformat = V4L2_PIX_FMT_RGB24;
+		/* fall-through */
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		pix->bytesperline = pix->width * 3;
+		break;
+	}
+
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->priv = 0;
+
+	return 0;
+}
+
+static int axi_hdmi_rx_s_fmt_vid_cap(struct file *file, void *priv_fh,
+	struct v4l2_format *f)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct v4l2_subdev_format fmt;
+	unsigned int config;
+	int ret;
+
+	if (axi_hdmi_rx_try_fmt_vid_cap(file, priv_fh, f))
+		return -EINVAL;
+
+	s->width = pix->width;
+	s->height = pix->height;
+	s->stride = pix->bytesperline;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YVYU:
+		fmt.format.code = MEDIA_BUS_FMT_YVYU8_1X16;
+		break;
+	case V4L2_PIX_FMT_VYUY:
+		fmt.format.code = MEDIA_BUS_FMT_VYUY8_1X16;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		fmt.format.code = MEDIA_BUS_FMT_YUYV8_1X16;
+		break;
+	default:
+		if (hdmi_rx->bus_width >= 24)
+			fmt.format.code = MEDIA_BUS_FMT_RGB888_1X24;
+		else /* CSC expects this */
+			fmt.format.code = MEDIA_BUS_FMT_YUYV8_1X16;
+		break;
+	}
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_BGR32:
+		config = 0;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		config = AXI_HDMI_RX_CONFIG_PACKED;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		config = AXI_HDMI_RX_CONFIG_BGR;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		config = AXI_HDMI_RX_CONFIG_PACKED | AXI_HDMI_RX_CONFIG_BGR;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		config = AXI_HDMI_RX_CONFIG_CSC_BYPASS |
+		    AXI_HDMI_RX_CONFIG_PACKED;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = ADV7611_PAD_SOURCE;
+	ret = v4l2_subdev_call(s->subdev, pad, set_fmt, NULL, &fmt);
+	if (ret)
+		return ret;
+
+	s->pixelformat = pix->pixelformat;
+
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_TIMING, 
+		(s->height << 16) | s->width);
+
+	config |= AXI_HDMI_RX_CONFIG_EDGE_SEL;
+
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_CONFIG, config);
+
+	return 0;
+}
+
+static int axi_hdmi_rx_enum_input(struct file *file, void *priv_fh,
+	struct v4l2_input *inp)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	switch (inp->index) {
+	case 0:
+		snprintf(inp->name, sizeof(inp->name), "HDMI-0");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->capabilities = V4L2_IN_CAP_DV_TIMINGS;
+
+	return v4l2_subdev_call(s->subdev, video, g_input_status, &inp->status);
+}
+
+static int axi_hdmi_rx_g_input(struct file *file, void *priv_fh, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int axi_hdmi_rx_s_input(struct file *file, void *priv_fh, unsigned int i)
+{
+	struct axi_hdmi_rx *hdmi_rx = video_drvdata(file);
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+
+	if (i != 0)
+		return -EINVAL;
+
+	return v4l2_subdev_call(s->subdev, video, s_routing,
+		ADV76XX_PAD_HDMI_PORT_A, 0, 0);
+}
+
+static const struct v4l2_ioctl_ops axi_hdmi_rx_ioctl_ops = {
+	.vidioc_querycap		= axi_hdmi_rx_querycap,
+	.vidioc_log_status		= axi_hdmi_rx_log_status,
+	.vidioc_streamon		= axi_hdmi_rx_streamon,
+	.vidioc_streamoff		= axi_hdmi_rx_streamoff,
+	.vidioc_enum_input		= axi_hdmi_rx_enum_input,
+	.vidioc_g_input			= axi_hdmi_rx_g_input,
+	.vidioc_s_input			= axi_hdmi_rx_s_input,
+	.vidioc_enum_fmt_vid_cap	= axi_hdmi_rx_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= axi_hdmi_rx_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= axi_hdmi_rx_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= axi_hdmi_rx_try_fmt_vid_cap,
+	.vidioc_s_dv_timings		= axi_hdmi_rx_s_dv_timings,
+	.vidioc_g_dv_timings		= axi_hdmi_rx_g_dv_timings,
+	.vidioc_query_dv_timings	= axi_hdmi_rx_query_dv_timings,
+	.vidioc_enum_dv_timings		= axi_hdmi_rx_enum_dv_timings,
+	.vidioc_dv_timings_cap		= axi_hdmi_rx_dv_timings_cap,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+	.vidioc_create_bufs 		= vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_g_register		= axi_hdmi_rx_g_register,
+	.vidioc_s_register		= axi_hdmi_rx_s_register,
+#endif
+};
+
+static void axi_hdmi_rx_notify(struct v4l2_subdev *sd, unsigned int notification,
+	void *arg)
+{
+	struct axi_hdmi_rx *hdmi_rx = to_axi_hdmi_rx(sd->v4l2_dev);
+	long hotplug = (long)arg;
+
+	switch (notification) {
+	case ADV76XX_HOTPLUG:
+		gpio_set_value_cansleep(hdmi_rx->hotplug_gpio, hotplug);
+		break;
+	default:
+		break;
+	}
+}
+
+static int axi_hdmi_rx_nodes_register(struct axi_hdmi_rx *hdmi_rx)
+{
+	struct axi_hdmi_rx_stream *s = &hdmi_rx->stream;
+	struct video_device *vdev = &s->vdev;
+	struct vb2_queue *q = &s->q;
+	int ret;
+
+	mutex_init(&s->lock);
+	snprintf(vdev->name, sizeof(vdev->name),
+		 "%s", hdmi_rx->v4l2_dev.name);
+	vdev->v4l2_dev = &hdmi_rx->v4l2_dev;
+	vdev->fops = &axi_hdmi_rx_fops;
+	vdev->release = video_device_release_empty;
+	vdev->ctrl_handler = s->subdev->ctrl_handler;
+	vdev->lock = &s->lock;
+	vdev->queue = q;
+	q->lock = &s->lock;
+	q->dev = hdmi_rx->v4l2_dev.dev;
+
+	INIT_LIST_HEAD(&s->queued_buffers);
+	spin_lock_init(&s->spinlock);
+
+	s->width = 800;
+	s->height = 600;
+	s->pixelformat = V4L2_PIX_FMT_BGR32;
+	s->stride = s->width * 4;
+
+	vdev->ioctl_ops = &axi_hdmi_rx_ioctl_ops;
+
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;
+	q->drv_priv = hdmi_rx;
+	q->buf_struct_size = sizeof(struct axi_hdmi_rx_buffer);
+	q->ops = &axi_hdmi_rx_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+
+	ret = vb2_queue_init(q);
+	if (ret)
+		return ret;
+
+	return video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+}
+
+static struct axi_hdmi_rx *notifier_to_axi_hdmi_rx(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct axi_hdmi_rx, notifier);
+}
+
+static int axi_hdmi_rx_async_bound(struct v4l2_async_notifier *notifier,
+	struct v4l2_subdev *subdev, struct v4l2_async_subdev *asd)
+{
+	struct axi_hdmi_rx *hdmi_rx = notifier_to_axi_hdmi_rx(notifier);
+	struct v4l2_subdev_format fmt;
+	int ret;
+
+	struct v4l2_subdev_edid edid = {
+		.pad = 0,
+		.start_block = 0,
+		.blocks = hdmi_rx->edid_blocks,
+		.edid = hdmi_rx->edid_data,
+	};
+
+	hdmi_rx->stream.subdev = subdev;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = ADV7611_PAD_SOURCE;
+	fmt.format.code = MEDIA_BUS_FMT_YUYV8_1X16;
+	ret = v4l2_subdev_call(subdev, pad, set_fmt, NULL, &fmt);
+	if (ret)
+		return ret;
+
+	ret = v4l2_subdev_call(subdev, video, s_routing, ADV76XX_PAD_HDMI_PORT_A,
+		0, 0);
+	if (ret)
+		return ret;
+
+	return v4l2_subdev_call(subdev, pad, set_edid, &edid);
+}
+
+static int axi_hdmi_rx_async_complete(struct v4l2_async_notifier *notifier)
+{
+	struct axi_hdmi_rx *hdmi_rx = notifier_to_axi_hdmi_rx(notifier);
+	int ret;
+
+	ret = v4l2_device_register_subdev_nodes(&hdmi_rx->v4l2_dev);
+	if (ret < 0)
+		return ret;
+
+	return axi_hdmi_rx_nodes_register(hdmi_rx);
+}
+
+static const struct v4l2_async_notifier_operations axi_hdmi_rx_async_ops = {
+	.bound = axi_hdmi_rx_async_bound,
+	.complete = axi_hdmi_rx_async_complete,
+};
+
+static int axi_hdmi_rx_load_edid(struct platform_device *pdev,
+	struct axi_hdmi_rx *hdmi_rx)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, "imageon_edid.bin", &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to load firmware: %d\n", ret);
+		return ret;
+	}
+
+	if (fw->size > 256) {
+		dev_err(&pdev->dev, "EDID firmware data too large.\n");
+		release_firmware(fw);
+		return -EINVAL;
+	}
+
+	if (fw->size > 128)
+		hdmi_rx->edid_blocks = 2;
+	else
+		hdmi_rx->edid_blocks = 1;
+
+	memcpy(hdmi_rx->edid_data, fw->data, fw->size);
+
+	release_firmware(fw);
+
+	return 0;
+}
+
+static int axi_hdmi_rx_probe(struct platform_device *pdev)
+{
+	struct device_node *ep_node;
+	struct axi_hdmi_rx *hdmi_rx;
+	struct resource *res;
+	struct v4l2_fwnode_endpoint bus_cfg;
+	int ret;
+
+	hdmi_rx = devm_kzalloc(&pdev->dev, sizeof(*hdmi_rx), GFP_KERNEL);
+	if (hdmi_rx == NULL)
+		return -ENOMEM;
+
+	hdmi_rx->hotplug_gpio = of_get_gpio(pdev->dev.of_node, 0);
+	if (!gpio_is_valid(hdmi_rx->hotplug_gpio))
+		return hdmi_rx->hotplug_gpio;
+
+	ret = devm_gpio_request_one(&pdev->dev,
+		hdmi_rx->hotplug_gpio, GPIOF_OUT_INIT_LOW, "HPD");
+	if (ret < 0)
+		return ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hdmi_rx->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hdmi_rx->base))
+		return PTR_ERR(hdmi_rx->base);
+
+	hdmi_rx->stream.chan = dma_request_slave_channel(&pdev->dev, "rx");
+	if (!hdmi_rx->stream.chan)
+		return -EPROBE_DEFER;
+
+	ret = axi_hdmi_rx_load_edid(pdev, hdmi_rx);
+	if (ret)
+		goto err_dma_release_channel;
+
+	snprintf(hdmi_rx->v4l2_dev.name, sizeof(hdmi_rx->v4l2_dev.name),
+		"axi_hdmi_rx");
+	hdmi_rx->v4l2_dev.notify = axi_hdmi_rx_notify;
+
+	video_set_drvdata(&hdmi_rx->stream.vdev, hdmi_rx);
+
+	ret = v4l2_device_register(&pdev->dev, &hdmi_rx->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register card: %d\n", ret);
+		goto err_dma_release_channel;
+	}
+
+	ep_node = of_graph_get_next_endpoint(pdev->dev.of_node, NULL);
+	if (!ep_node) {
+		ret = -EINVAL;
+		goto err_device_unregister;
+	}
+	bus_cfg.bus.parallel.bus_width = 0;
+	v4l2_fwnode_endpoint_parse(of_fwnode_handle(ep_node), &bus_cfg);
+	if (bus_cfg.bus.parallel.bus_width)
+		hdmi_rx->bus_width = bus_cfg.bus.parallel.bus_width;
+	else
+		hdmi_rx->bus_width = 16;
+
+	hdmi_rx->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+	hdmi_rx->asd.match.fwnode = of_fwnode_handle(of_graph_get_remote_port_parent(ep_node));
+
+	hdmi_rx->asds[0] = &hdmi_rx->asd;
+	hdmi_rx->notifier.subdevs = hdmi_rx->asds;
+	hdmi_rx->notifier.num_subdevs = ARRAY_SIZE(hdmi_rx->asds);
+	hdmi_rx->notifier.ops = &axi_hdmi_rx_async_ops;
+
+	ret = v4l2_async_notifier_register(&hdmi_rx->v4l2_dev,
+		&hdmi_rx->notifier);
+	if (ret) {
+		dev_err(&pdev->dev, "Error %d registering device nodes\n", ret);
+		goto err_device_unregister;
+	}
+
+	axi_hdmi_rx_write(hdmi_rx, AXI_HDMI_RX_REG_CONFIG,
+			AXI_HDMI_RX_CONFIG_EDGE_SEL);
+
+	return 0;
+
+err_device_unregister:
+	v4l2_device_unregister(&hdmi_rx->v4l2_dev);
+err_dma_release_channel:
+	dma_release_channel(hdmi_rx->stream.chan);
+	return ret;
+}
+
+static int axi_hdmi_rx_remove(struct platform_device *pdev)
+{
+	struct axi_hdmi_rx *hdmi_rx = platform_get_drvdata(pdev);
+
+	v4l2_async_notifier_unregister(&hdmi_rx->notifier);
+	video_unregister_device(&hdmi_rx->stream.vdev);
+	v4l2_device_unregister(&hdmi_rx->v4l2_dev);
+	dma_release_channel(hdmi_rx->stream.chan);
+
+	return 0;
+}
+
+static const struct of_device_id axi_hdmi_rx_of_match[] = {
+	{ .compatible = "adi,axi-hdmi-rx-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, axi_hdmi_rx_of_match);
+
+static struct platform_driver axi_hdmi_rx_driver = {
+	.driver = {
+		.name = "axi-hdmi-rx",
+		.owner = THIS_MODULE,
+		.of_match_table = axi_hdmi_rx_of_match,
+	},
+	.probe = axi_hdmi_rx_probe,
+	.remove = axi_hdmi_rx_remove,
+};
+module_platform_driver(axi_hdmi_rx_driver);
diff --git a/drivers/media/platform/imageon-bridge.c b/drivers/media/platform/imageon-bridge.c
new file mode 100644
index 000000000000..e527c0cfccbb
--- /dev/null
+++ b/drivers/media/platform/imageon-bridge.c
@@ -0,0 +1,301 @@
+/*
+ * IMAGEON V4L2 bridge driver
+ *
+ * Copyright 2015 Analog Devices Inc.
+ *  Author: Dragos Bogdan <dragos.bogdan@analog.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include <linux/of_graph.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/i2c/adv7604.h>
+
+#define INPUT_SUBDEV		0
+#define OUTPUT_SUBDEV		1
+
+struct imageon_subdev {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev *subdev;
+};
+
+struct imageon_bridge {
+	struct imageon_subdev imageon_subdev[2];
+	struct v4l2_device v4l2_dev;
+	struct v4l2_async_notifier notifier;
+	struct media_device media_dev;
+
+	u8 input_edid_data[256];
+	u8 input_edid_blocks;
+
+	int irq;
+};
+
+static struct imageon_bridge *
+	notifier_to_imageon_bridge(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct imageon_bridge, notifier);
+}
+
+static int imageon_bridge_load_input_edid(struct platform_device *pdev,
+	struct imageon_bridge *bridge)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, "imageon_edid.bin", &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to load firmware: %d\n", ret);
+		return ret;
+	}
+
+	if (fw->size > 256) {
+		dev_err(&pdev->dev, "EDID firmware data too large\n");
+		release_firmware(fw);
+		bridge->input_edid_blocks = 0;
+		return -EINVAL;
+	}
+
+	if (fw->size > 128)
+		bridge->input_edid_blocks = 2;
+	else
+		bridge->input_edid_blocks = 1;
+
+	memcpy(bridge->input_edid_data, fw->data, fw->size);
+
+	release_firmware(fw);
+
+	return 0;
+}
+
+static irqreturn_t imageon_bridge_hdmiio_int_handler(int irq, void *dev_id)
+{
+	struct imageon_bridge *bridge = dev_id;
+
+	if (bridge->imageon_subdev[INPUT_SUBDEV].subdev != NULL)
+		v4l2_subdev_call(bridge->imageon_subdev[INPUT_SUBDEV].subdev,
+				core, interrupt_service_routine, 0, NULL);
+
+	if (bridge->imageon_subdev[OUTPUT_SUBDEV].subdev != NULL)
+		v4l2_subdev_call(bridge->imageon_subdev[OUTPUT_SUBDEV].subdev,
+				core, interrupt_service_routine, 0, NULL);
+
+	return IRQ_HANDLED;
+}
+
+static int imageon_bridge_async_bound(struct v4l2_async_notifier *notifier,
+	struct v4l2_subdev *subdev, struct v4l2_async_subdev *asd)
+{
+	struct imageon_bridge *bridge = notifier_to_imageon_bridge(notifier);
+	struct v4l2_subdev_edid edid = {
+		.pad = 0,
+		.start_block = 0,
+		.blocks = bridge->input_edid_blocks,
+		.edid = bridge->input_edid_data,
+	};
+	int ret;
+
+	if (bridge->imageon_subdev[INPUT_SUBDEV].asd.match.fwnode
+			== of_fwnode_handle(subdev->dev->of_node)) {
+
+		bridge->imageon_subdev[INPUT_SUBDEV].subdev = subdev;
+
+		ret = v4l2_subdev_call(subdev, video, s_routing,
+					ADV76XX_PAD_HDMI_PORT_A, 0, 0);
+		if (ret)
+			return ret;
+
+		ret = v4l2_subdev_call(subdev, pad, set_edid, &edid);
+		if (ret)
+			return ret;
+	}
+
+	if (bridge->imageon_subdev[OUTPUT_SUBDEV].asd.match.fwnode
+			== of_fwnode_handle(subdev->dev->of_node)) {
+
+		bridge->imageon_subdev[OUTPUT_SUBDEV].subdev = subdev;
+
+		ret = v4l2_subdev_call(bridge->imageon_subdev[OUTPUT_SUBDEV].subdev,
+					video, s_stream, 1);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int imageon_bridge_async_complete(struct v4l2_async_notifier *notifier)
+{
+	struct imageon_bridge *bridge = notifier_to_imageon_bridge(notifier);
+	struct v4l2_subdev_format fmt;
+	int ret;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = ADV7611_PAD_SOURCE;
+	fmt.format.code = MEDIA_BUS_FMT_YUYV8_1X16;
+	ret = v4l2_subdev_call(bridge->imageon_subdev[INPUT_SUBDEV].subdev,
+				pad, set_fmt, NULL, &fmt);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+
+static const struct v4l2_async_notifier_operations imageon_async_ops = {
+	.bound = imageon_bridge_async_bound,
+	.complete = imageon_bridge_async_complete,
+};
+
+static struct imageon_bridge *imageon_bridge_parse_dt(struct device *dev)
+{
+	struct imageon_bridge *bridge;
+	struct device_node *ep = NULL;
+	struct device_node *next;
+	int index;
+
+	bridge = devm_kzalloc(dev, sizeof(struct imageon_bridge), GFP_KERNEL);
+	if (!bridge) {
+		dev_err(dev, "could not allocate memory for imageon_bridge\n");
+		return NULL;
+	}
+
+	for (index = 0; index < 2; index++) {
+		next = of_graph_get_next_endpoint(dev->of_node, ep);
+		if (!next) {
+			return NULL;
+		}
+		ep = next;
+
+		bridge->imageon_subdev[index].asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		bridge->imageon_subdev[index].asd.match.fwnode =
+			of_fwnode_handle(of_graph_get_remote_port_parent(next));
+	}
+
+	return bridge;
+}
+
+static int imageon_bridge_probe(struct platform_device *pdev)
+{
+	struct imageon_bridge *bridge;
+	struct v4l2_async_subdev **asubdevs;
+	int ret;
+
+	bridge = imageon_bridge_parse_dt(&pdev->dev);
+	if (bridge == NULL)
+		return -ENOMEM;
+
+	bridge->irq = platform_get_irq(pdev, 0);
+	if (bridge->irq > 0) {
+		ret = request_threaded_irq(bridge->irq, NULL,
+				imageon_bridge_hdmiio_int_handler,
+				IRQF_ONESHOT | IRQF_TRIGGER_LOW, dev_name(&pdev->dev),
+				bridge);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	ret = imageon_bridge_load_input_edid(pdev, bridge);
+	if (ret < 0)
+		goto err;
+
+	bridge->media_dev.dev = &pdev->dev;
+	strlcpy(bridge->media_dev.model, "IMAGEON V4L2 Bridge",
+		sizeof(bridge->media_dev.model));
+	bridge->media_dev.hw_revision = 0;
+
+	media_device_init(&bridge->media_dev);
+
+	ret = media_device_register(&bridge->media_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register media_device\n");
+		goto err;
+	}
+	bridge->v4l2_dev.mdev = &bridge->media_dev;
+
+	snprintf(bridge->v4l2_dev.name, sizeof(bridge->v4l2_dev.name),
+		"imageon_v4l2_bridge");
+
+	ret = v4l2_device_register(&pdev->dev, &bridge->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register v4l2_device\n");
+		goto err;
+	}
+
+	asubdevs = devm_kzalloc(&pdev->dev, sizeof(struct v4l2_async_subdev*) * 2,
+		GFP_KERNEL);
+	if (bridge == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	asubdevs[INPUT_SUBDEV] = &bridge->imageon_subdev[INPUT_SUBDEV].asd;
+	asubdevs[OUTPUT_SUBDEV] = &bridge->imageon_subdev[OUTPUT_SUBDEV].asd;
+
+	bridge->notifier.subdevs = asubdevs;
+	bridge->notifier.num_subdevs = 2;
+	bridge->notifier.ops = &imageon_async_ops;
+
+	ret = v4l2_async_notifier_register(&bridge->v4l2_dev,
+		&bridge->notifier);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register device nodes\n");
+		goto err;
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&bridge->v4l2_dev);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+
+err:
+	if (bridge->irq > 0)
+		free_irq(bridge->irq, pdev);
+	return ret;
+}
+
+static int imageon_bridge_remove(struct platform_device *pdev)
+{
+	struct imageon_bridge *bridge = platform_get_drvdata(pdev);
+
+	v4l2_async_notifier_unregister(&bridge->notifier);
+	v4l2_device_unregister(&bridge->v4l2_dev);
+	media_device_unregister(&bridge->media_dev);
+	if (bridge->irq > 0)
+		free_irq(bridge->irq, pdev);
+
+	return 0;
+}
+
+static const struct of_device_id imageon_bridge_of_match[] = {
+	{ .compatible = "adi,imageon-v4l2-bridge-1.00.a", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, imageon_bridge_of_match);
+
+static struct platform_driver imageon_bridge_driver = {
+	.driver = {
+		.name = "imageon-bridge",
+		.owner = THIS_MODULE,
+		.of_match_table = imageon_bridge_of_match,
+	},
+	.probe = imageon_bridge_probe,
+	.remove = imageon_bridge_remove,
+};
+module_platform_driver(imageon_bridge_driver);
+
+MODULE_DESCRIPTION("Imageon video bridge");
+MODULE_LICENSE("GPL v2");
-- 
2.17.1

