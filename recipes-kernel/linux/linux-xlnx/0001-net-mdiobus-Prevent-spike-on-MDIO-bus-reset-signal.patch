From 3690dcb26b6a135f0dbf28a418fe8c4ac74fd9e3 Mon Sep 17 00:00:00 2001
From: Mike Looijmans <mike.looijmans@topic.nl>
Date: Tue, 26 Jan 2021 08:09:34 +0100
Subject: [PATCH] net: mdiobus: Prevent spike on MDIO bus reset signal

The mdio_bus reset code first de-asserted the reset by allocating with
GPIOD_OUT_LOW, then asserted and de-asserted again. In other words, if
the reset signal defaulted to asserted, there'd be a short "spike"
before the reset.

Instead, directly assert the reset signal using GPIOD_OUT_HIGH, this
removes the spike and also removes a line of code since the signal
is already high.

Upstream-status: Pending
Signed-off-by: Mike Looijmans <mike.looijmans@topic.nl>
---
 drivers/net/phy/mdio_bus.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/drivers/net/phy/mdio_bus.c b/drivers/net/phy/mdio_bus.c
index a9e054d8172e..b888f540814e 100644
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -391,8 +391,8 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 
 	mutex_init(&bus->mdio_lock);
 
-	/* de-assert bus level PHY GPIO reset */
-	gpiod = devm_gpiod_get_optional(&bus->dev, "reset", GPIOD_OUT_LOW);
+	/* assert bus level PHY GPIO reset */
+	gpiod = devm_gpiod_get_optional(&bus->dev, "reset", GPIOD_OUT_HIGH);
 	if (IS_ERR(gpiod)) {
 		dev_err(&bus->dev, "mii_bus %s couldn't get reset GPIO\n",
 			bus->id);
@@ -401,7 +401,6 @@ int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 	} else	if (gpiod) {
 		bus->reset_gpiod = gpiod;
 
-		gpiod_set_value_cansleep(gpiod, 1);
 		i = bus->reset_delay_us;
 		usleep_range(i, i + max_t(unsigned int, i / 10, 100));
 		gpiod_set_value_cansleep(gpiod, 0);
-- 
2.17.1

